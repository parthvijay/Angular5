{"remainingRequest":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/angular-2-dropdown-multiselect/dropdown/search-filter.pipe.js","dependencies":[{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/angular-2-dropdown-multiselect/dropdown/search-filter.pipe.js","mtime":1511925561000},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/cache-loader/dist/cjs.js","mtime":1525383502481},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { Pipe } from '@angular/core';\nvar MultiSelectSearchFilter = /*@__PURE__*/ (function () {\n    function MultiSelectSearchFilter() {\n        this._searchCache = {};\n        this._searchCacheInclusive = {};\n        this._prevSkippedItems = {};\n    }\n    MultiSelectSearchFilter.prototype.transform = function (options, str, limit, renderLimit) {\n        if (str === void 0) {\n            str = '';\n        }\n        if (limit === void 0) {\n            limit = 0;\n        }\n        if (renderLimit === void 0) {\n            renderLimit = 0;\n        }\n        str = str.toLowerCase();\n        // Drop cache because options were updated\n        if (options !== this._lastOptions) {\n            this._lastOptions = options;\n            this._searchCache = {};\n            this._searchCacheInclusive = {};\n            this._prevSkippedItems = {};\n        }\n        var filteredOpts = this._searchCache.hasOwnProperty(str)\n            ? this._searchCache[str]\n            : this._doSearch(options, str, limit);\n        var isUnderLimit = options.length <= limit;\n        return isUnderLimit\n            ? filteredOpts\n            : this._limitRenderedItems(filteredOpts, renderLimit);\n    };\n    MultiSelectSearchFilter.prototype._getSubsetOptions = function (options, prevOptions, prevSearchStr) {\n        var prevInclusiveOrIdx = this._searchCacheInclusive[prevSearchStr];\n        if (prevInclusiveOrIdx === true) {\n            // If have previous results and it was inclusive, do only subsearch\n            return prevOptions;\n        }\n        else if (typeof prevInclusiveOrIdx === 'number') {\n            // Or reuse prev results with unchecked ones\n            return prevOptions.concat(options.slice(prevInclusiveOrIdx));\n        }\n        return options;\n    };\n    MultiSelectSearchFilter.prototype._doSearch = function (options, str, limit) {\n        var prevStr = str.slice(0, -1);\n        var prevResults = this._searchCache[prevStr];\n        var prevResultShift = this._prevSkippedItems[prevStr] || 0;\n        if (prevResults) {\n            options = this._getSubsetOptions(options, prevResults, prevStr);\n        }\n        var optsLength = options.length;\n        var maxFound = limit > 0 ? Math.min(limit, optsLength) : optsLength;\n        var regexp = new RegExp(this._escapeRegExp(str), 'i');\n        var filteredOpts = [];\n        var i = 0, founded = 0, removedFromPrevResult = 0;\n        var doesOptionMatch = function (option) { return regexp.test(option.name); };\n        var getChildren = function (option) {\n            return options.filter(function (child) { return child.parentId === option.id; });\n        };\n        var getParent = function (option) {\n            return options.find(function (parent) { return option.parentId === parent.id; });\n        };\n        var foundFn = function (item) { filteredOpts.push(item); founded++; };\n        var notFoundFn = prevResults ? function () { return removedFromPrevResult++; } : function () { };\n        for (; i < optsLength && founded < maxFound; ++i) {\n            var option = options[i];\n            var directMatch = doesOptionMatch(option);\n            if (directMatch) {\n                foundFn(option);\n                continue;\n            }\n            if (typeof option.parentId === 'undefined') {\n                var childrenMatch = getChildren(option).some(doesOptionMatch);\n                if (childrenMatch) {\n                    foundFn(option);\n                    continue;\n                }\n            }\n            if (typeof option.parentId !== 'undefined') {\n                var parentMatch = doesOptionMatch(getParent(option));\n                if (parentMatch) {\n                    foundFn(option);\n                    continue;\n                }\n            }\n            notFoundFn();\n        }\n        var totalIterations = i + prevResultShift;\n        this._searchCache[str] = filteredOpts;\n        this._searchCacheInclusive[str] = i === optsLength || totalIterations;\n        this._prevSkippedItems[str] = removedFromPrevResult + prevResultShift;\n        return filteredOpts;\n    };\n    MultiSelectSearchFilter.prototype._limitRenderedItems = function (items, limit) {\n        return items.length > limit && limit > 0 ? items.slice(0, limit) : items;\n    };\n    MultiSelectSearchFilter.prototype._escapeRegExp = function (str) {\n        return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n    };\n    return MultiSelectSearchFilter;\n}());\nexport { MultiSelectSearchFilter };\n//# sourceMappingURL=search-filter.pipe.js.map \n",null]}