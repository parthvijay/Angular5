{"remainingRequest":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowModels/enterprise/enterpriseRowModel.js","dependencies":[{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowModels/enterprise/enterpriseRowModel.js","mtime":1523957359000},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/cache-loader/dist/cjs.js","mtime":1525383502481},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// ag-grid-enterprise v17.1.1\n\"use strict\";\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nvar __param = /*@__PURE__*/ require(\"tslib\").__param;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ag_grid_1 = require(\"ag-grid\");\nvar enterpriseCache_1 = require(\"./enterpriseCache\");\nvar EnterpriseRowModel = /*@__PURE__*/ (function (_super) {\n    __extends(EnterpriseRowModel, _super);\n    function EnterpriseRowModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    EnterpriseRowModel.prototype.postConstruct = function () {\n        this.rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();\n        this.addEventListeners();\n        var datasource = this.gridOptionsWrapper.getEnterpriseDatasource();\n        if (ag_grid_1._.exists(datasource)) {\n            this.setDatasource(datasource);\n        }\n    };\n    EnterpriseRowModel.prototype.destroy = function () {\n        _super.prototype.destroy.call(this);\n    };\n    EnterpriseRowModel.prototype.destroyDatasource = function () {\n        if (this.datasource && this.datasource.destroy) {\n            this.datasource.destroy();\n        }\n        this.datasource = null;\n    };\n    EnterpriseRowModel.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('EnterpriseRowModel');\n    };\n    EnterpriseRowModel.prototype.isLastRowFound = function () {\n        if (ag_grid_1._.exists(this.rootNode) && ag_grid_1._.exists(this.rootNode.childrenCache)) {\n            return this.rootNode.childrenCache.isMaxRowFound();\n        }\n        else {\n            return false;\n        }\n    };\n    EnterpriseRowModel.prototype.addEventListeners = function () {\n        this.addDestroyableEventListener(this.eventService, ag_grid_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, ag_grid_1.Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));\n        this.addDestroyableEventListener(this.eventService, ag_grid_1.Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.onPivotModeChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, ag_grid_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onColumnEverything.bind(this));\n        this.addDestroyableEventListener(this.eventService, ag_grid_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, ag_grid_1.Events.EVENT_COLUMN_PIVOT_CHANGED, this.onColumnPivotChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, ag_grid_1.Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n        this.addDestroyableEventListener(this.eventService, ag_grid_1.Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n    };\n    EnterpriseRowModel.prototype.onColumnEverything = function () {\n        // this is a hack for one customer only, so they can suppress the resetting of the columns.\n        // The problem the customer had was they were api.setColumnDefs() after the data source came\n        // back with data. So this stops the reload from the grid after the data comes back.\n        // Once we have \"AG-1591 Allow delta changes to columns\" fixed, then this hack can be taken out.\n        if (this.gridOptionsWrapper.isSuppressEnterpriseResetOnNewColumns()) {\n            return;\n        }\n        // every other customer can continue as normal and have it working!!!\n        this.reset();\n    };\n    EnterpriseRowModel.prototype.onFilterChanged = function () {\n        this.reset();\n    };\n    EnterpriseRowModel.prototype.onSortChanged = function () {\n        this.reset();\n    };\n    EnterpriseRowModel.prototype.onValueChanged = function () {\n        this.reset();\n    };\n    EnterpriseRowModel.prototype.onColumnRowGroupChanged = function () {\n        this.reset();\n    };\n    EnterpriseRowModel.prototype.onColumnPivotChanged = function () {\n        this.reset();\n    };\n    EnterpriseRowModel.prototype.onPivotModeChanged = function () {\n        this.reset();\n    };\n    EnterpriseRowModel.prototype.onRowGroupOpened = function (event) {\n        var rowNode = event.node;\n        if (rowNode.expanded) {\n            if (ag_grid_1._.missing(rowNode.childrenCache)) {\n                this.createNodeCache(rowNode);\n            }\n        }\n        else {\n            if (this.gridOptionsWrapper.isPurgeClosedRowNodes() && ag_grid_1._.exists(rowNode.childrenCache)) {\n                rowNode.childrenCache.destroy();\n                rowNode.childrenCache = null;\n            }\n        }\n        this.updateRowIndexesAndBounds();\n        var modelUpdatedEvent = {\n            type: ag_grid_1.Events.EVENT_MODEL_UPDATED,\n            api: this.gridOptionsWrapper.getApi(),\n            columnApi: this.gridOptionsWrapper.getColumnApi(),\n            newPage: false,\n            newData: false,\n            animate: true,\n            keepRenderedRows: true\n        };\n        this.eventService.dispatchEvent(modelUpdatedEvent);\n    };\n    EnterpriseRowModel.prototype.reset = function () {\n        this.rootNode = new ag_grid_1.RowNode();\n        this.rootNode.group = true;\n        this.rootNode.level = -1;\n        this.context.wireBean(this.rootNode);\n        if (this.datasource) {\n            this.createNewRowNodeBlockLoader();\n            this.cacheParams = this.createCacheParams();\n            this.createNodeCache(this.rootNode);\n            this.updateRowIndexesAndBounds();\n        }\n        // this event: 1) clears selection 2) updates filters 3) shows/hides 'no rows' overlay\n        var rowDataChangedEvent = {\n            type: ag_grid_1.Events.EVENT_ROW_DATA_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(rowDataChangedEvent);\n        // this gets the row to render rows (or remove the previously rendered rows, as it's blank to start).\n        // important to NOT pass in an event with keepRenderedRows or animate, as we want the renderer\n        // to treat the rows as new rows, as it's all new data\n        var modelUpdatedEvent = {\n            type: ag_grid_1.Events.EVENT_MODEL_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            animate: false,\n            keepRenderedRows: false,\n            newData: false,\n            newPage: false\n        };\n        this.eventService.dispatchEvent(modelUpdatedEvent);\n    };\n    EnterpriseRowModel.prototype.createNewRowNodeBlockLoader = function () {\n        this.destroyRowNodeBlockLoader();\n        var maxConcurrentRequests = this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests();\n        this.rowNodeBlockLoader = new ag_grid_1.RowNodeBlockLoader(maxConcurrentRequests);\n        this.context.wireBean(this.rowNodeBlockLoader);\n    };\n    EnterpriseRowModel.prototype.destroyRowNodeBlockLoader = function () {\n        if (this.rowNodeBlockLoader) {\n            this.rowNodeBlockLoader.destroy();\n            this.rowNodeBlockLoader = null;\n        }\n    };\n    EnterpriseRowModel.prototype.setDatasource = function (datasource) {\n        this.destroyDatasource();\n        this.datasource = datasource;\n        this.reset();\n    };\n    EnterpriseRowModel.prototype.toValueObjects = function (columns) {\n        var _this = this;\n        return columns.map(function (col) {\n            return ({\n                id: col.getId(),\n                aggFunc: col.getAggFunc(),\n                displayName: _this.columnController.getDisplayNameForColumn(col, 'model'),\n                field: col.getColDef().field\n            });\n        });\n    };\n    EnterpriseRowModel.prototype.createCacheParams = function () {\n        var rowGroupColumnVos = this.toValueObjects(this.columnController.getRowGroupColumns());\n        var valueColumnVos = this.toValueObjects(this.columnController.getValueColumns());\n        var pivotColumnVos = this.toValueObjects(this.columnController.getPivotColumns());\n        var dynamicRowHeight = this.gridOptionsWrapper.isDynamicRowHeight();\n        var maxBlocksInCache = this.gridOptionsWrapper.getMaxBlocksInCache();\n        if (dynamicRowHeight && maxBlocksInCache >= 0) {\n            console.warn('ag-Grid: Enterprise Row Model does not support Dynamic Row Height and Cache Purging. ' +\n                'Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.');\n            maxBlocksInCache = undefined;\n        }\n        if (maxBlocksInCache >= 0 && this.columnController.isAutoRowHeightActive()) {\n            console.warn('ag-Grid: Enterprise Row Model does not support Auto Row Height and Cache Purging. ' +\n                'Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.');\n            maxBlocksInCache = undefined;\n        }\n        var params = {\n            // the columns the user has grouped and aggregated by\n            valueCols: valueColumnVos,\n            rowGroupCols: rowGroupColumnVos,\n            pivotCols: pivotColumnVos,\n            pivotMode: this.columnController.isPivotMode(),\n            // sort and filter model\n            filterModel: this.filterManager.getFilterModel(),\n            sortModel: this.extractSortModel(),\n            rowNodeBlockLoader: this.rowNodeBlockLoader,\n            datasource: this.datasource,\n            lastAccessedSequence: new ag_grid_1.NumberSequence(),\n            overflowSize: 1,\n            initialRowCount: 1,\n            maxConcurrentRequests: this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests(),\n            maxBlocksInCache: maxBlocksInCache,\n            blockSize: this.gridOptionsWrapper.getCacheBlockSize(),\n            rowHeight: this.rowHeight,\n            dynamicRowHeight: dynamicRowHeight\n        };\n        // set defaults\n        if (!(params.maxConcurrentRequests >= 1)) {\n            params.maxConcurrentRequests = 2;\n        }\n        // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the\n        // server for one page at a time. so the default if not specified is 100.\n        if (!(params.blockSize >= 1)) {\n            params.blockSize = 100;\n        }\n        // if user doesn't give initial rows to display, we assume zero\n        if (!(params.initialRowCount >= 1)) {\n            params.initialRowCount = 0;\n        }\n        // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past\n        // the current page and request first row of next page\n        if (!(params.overflowSize >= 1)) {\n            params.overflowSize = 1;\n        }\n        return params;\n    };\n    EnterpriseRowModel.prototype.createNodeCache = function (rowNode) {\n        var cache = new enterpriseCache_1.EnterpriseCache(this.cacheParams, rowNode);\n        this.context.wireBean(cache);\n        cache.addEventListener(ag_grid_1.RowNodeCache.EVENT_CACHE_UPDATED, this.onCacheUpdated.bind(this));\n        rowNode.childrenCache = cache;\n    };\n    EnterpriseRowModel.prototype.onCacheUpdated = function () {\n        this.updateRowIndexesAndBounds();\n        var modelUpdatedEvent = {\n            type: ag_grid_1.Events.EVENT_MODEL_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            animate: true,\n            keepRenderedRows: true,\n            newPage: false,\n            newData: false\n        };\n        this.eventService.dispatchEvent(modelUpdatedEvent);\n    };\n    EnterpriseRowModel.prototype.updateRowIndexesAndBounds = function () {\n        var cacheExists = ag_grid_1._.exists(this.rootNode) && ag_grid_1._.exists(this.rootNode.childrenCache);\n        if (cacheExists) {\n            // todo: should not be casting here, the RowModel should use IEnterpriseRowModel interface?\n            var enterpriseCache = this.rootNode.childrenCache;\n            this.resetRowTops(enterpriseCache);\n            this.setDisplayIndexes(enterpriseCache);\n        }\n    };\n    EnterpriseRowModel.prototype.setDisplayIndexes = function (cache) {\n        var numberSequence = new ag_grid_1.NumberSequence();\n        var nextRowTop = { value: 0 };\n        cache.setDisplayIndexes(numberSequence, nextRowTop);\n    };\n    // resetting row tops is needed for animation, as part of the operation is saving the old location,\n    // which is needed for rows that are transitioning in\n    EnterpriseRowModel.prototype.resetRowTops = function (cache) {\n        var numberSequence = new ag_grid_1.NumberSequence();\n        cache.forEachNodeDeep(function (rowNode) { return rowNode.clearRowTop(); }, numberSequence);\n    };\n    EnterpriseRowModel.prototype.getRow = function (index) {\n        var cacheExists = ag_grid_1._.exists(this.rootNode) && ag_grid_1._.exists(this.rootNode.childrenCache);\n        if (cacheExists) {\n            return this.rootNode.childrenCache.getRow(index);\n        }\n        else {\n            return null;\n        }\n    };\n    EnterpriseRowModel.prototype.getPageFirstRow = function () {\n        return 0;\n    };\n    EnterpriseRowModel.prototype.getPageLastRow = function () {\n        var cacheExists = ag_grid_1._.exists(this.rootNode) && ag_grid_1._.exists(this.rootNode.childrenCache);\n        var lastRow;\n        if (cacheExists) {\n            // todo: should not be casting here, the RowModel should use IEnterpriseRowModel interface?\n            var enterpriseCache = this.rootNode.childrenCache;\n            lastRow = enterpriseCache.getDisplayIndexEnd() - 1;\n        }\n        else {\n            lastRow = 0;\n        }\n        return lastRow;\n    };\n    EnterpriseRowModel.prototype.getRowCount = function () {\n        return this.getPageLastRow() + 1;\n    };\n    EnterpriseRowModel.prototype.getRowBounds = function (index) {\n        var cacheMissing = ag_grid_1._.missing(this.rootNode) || ag_grid_1._.missing(this.rootNode.childrenCache);\n        if (cacheMissing) {\n            return {\n                rowTop: 0,\n                rowHeight: this.rowHeight\n            };\n        }\n        var enterpriseCache = this.rootNode.childrenCache;\n        return enterpriseCache.getRowBounds(index);\n    };\n    EnterpriseRowModel.prototype.getRowIndexAtPixel = function (pixel) {\n        if (pixel === 0)\n            return 0;\n        var cacheMissing = ag_grid_1._.missing(this.rootNode) || ag_grid_1._.missing(this.rootNode.childrenCache);\n        if (cacheMissing)\n            return 0;\n        var enterpriseCache = this.rootNode.childrenCache;\n        var result = enterpriseCache.getRowIndexAtPixel(pixel);\n        return result;\n    };\n    EnterpriseRowModel.prototype.getCurrentPageHeight = function () {\n        var pageHeight = this.rowHeight * this.getRowCount();\n        return pageHeight;\n    };\n    EnterpriseRowModel.prototype.isEmpty = function () {\n        return false;\n    };\n    EnterpriseRowModel.prototype.isRowsToRender = function () {\n        return this.getRowCount() > 0;\n    };\n    EnterpriseRowModel.prototype.getType = function () {\n        return ag_grid_1.Constants.ROW_MODEL_TYPE_ENTERPRISE;\n    };\n    EnterpriseRowModel.prototype.forEachNode = function (callback) {\n        if (this.rootNode && this.rootNode.childrenCache) {\n            this.rootNode.childrenCache.forEachNodeDeep(callback, new ag_grid_1.NumberSequence());\n        }\n    };\n    EnterpriseRowModel.prototype.purgeCache = function (route) {\n        if (route === void 0) {\n            route = [];\n        }\n        if (this.rootNode && this.rootNode.childrenCache) {\n            var topLevelCache = this.rootNode.childrenCache;\n            var cacheToPurge = topLevelCache.getChildCache(route);\n            if (cacheToPurge) {\n                cacheToPurge.purgeCache();\n            }\n        }\n    };\n    EnterpriseRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n        if (ag_grid_1._.exists(firstInRange) && firstInRange.parent !== lastInRange.parent)\n            return [];\n        return lastInRange.parent.childrenCache.getRowNodesInRange(firstInRange, lastInRange);\n    };\n    EnterpriseRowModel.prototype.getBlockState = function () {\n        if (this.rowNodeBlockLoader) {\n            return this.rowNodeBlockLoader.getBlockState();\n        }\n        else {\n            return null;\n        }\n    };\n    EnterpriseRowModel.prototype.isRowPresent = function (rowNode) {\n        return false;\n    };\n    EnterpriseRowModel.prototype.extractSortModel = function () {\n        var sortModel = this.sortController.getSortModel();\n        var rowGroupCols = this.toValueObjects(this.columnController.getRowGroupColumns());\n        // find index of auto group column in sort model\n        var index = -1;\n        for (var i = 0; i < sortModel.length; ++i) {\n            if (sortModel[i].colId === 'ag-Grid-AutoColumn') {\n                index = i;\n                break;\n            }\n        }\n        // replace auto column with individual group columns\n        if (index > -1) {\n            var individualGroupCols = rowGroupCols.map(function (group) {\n                return {\n                    colId: group.field,\n                    sort: sortModel[index].sort\n                };\n            });\n            // remove auto group column\n            sortModel.splice(index, 1);\n            // insert individual group columns\n            for (var i = 0; i < individualGroupCols.length; i++) {\n                sortModel.splice(index++, 0, individualGroupCols[i]);\n            }\n        }\n        return sortModel;\n    };\n    ;\n    __decorate([\n        ag_grid_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", ag_grid_1.GridOptionsWrapper)\n    ], EnterpriseRowModel.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        ag_grid_1.Autowired('eventService'),\n        __metadata(\"design:type\", ag_grid_1.EventService)\n    ], EnterpriseRowModel.prototype, \"eventService\", void 0);\n    __decorate([\n        ag_grid_1.Autowired('context'),\n        __metadata(\"design:type\", ag_grid_1.Context)\n    ], EnterpriseRowModel.prototype, \"context\", void 0);\n    __decorate([\n        ag_grid_1.Autowired('columnController'),\n        __metadata(\"design:type\", ag_grid_1.ColumnController)\n    ], EnterpriseRowModel.prototype, \"columnController\", void 0);\n    __decorate([\n        ag_grid_1.Autowired('filterManager'),\n        __metadata(\"design:type\", ag_grid_1.FilterManager)\n    ], EnterpriseRowModel.prototype, \"filterManager\", void 0);\n    __decorate([\n        ag_grid_1.Autowired('sortController'),\n        __metadata(\"design:type\", ag_grid_1.SortController)\n    ], EnterpriseRowModel.prototype, \"sortController\", void 0);\n    __decorate([\n        ag_grid_1.Autowired('gridApi'),\n        __metadata(\"design:type\", ag_grid_1.GridApi)\n    ], EnterpriseRowModel.prototype, \"gridApi\", void 0);\n    __decorate([\n        ag_grid_1.Autowired('columnApi'),\n        __metadata(\"design:type\", ag_grid_1.ColumnApi)\n    ], EnterpriseRowModel.prototype, \"columnApi\", void 0);\n    __decorate([\n        ag_grid_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], EnterpriseRowModel.prototype, \"postConstruct\", null);\n    __decorate([\n        ag_grid_1.PreDestroy,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], EnterpriseRowModel.prototype, \"destroy\", null);\n    __decorate([\n        ag_grid_1.PreDestroy,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], EnterpriseRowModel.prototype, \"destroyDatasource\", null);\n    __decorate([\n        __param(0, ag_grid_1.Qualifier('loggerFactory')),\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [ag_grid_1.LoggerFactory]),\n        __metadata(\"design:returntype\", void 0)\n    ], EnterpriseRowModel.prototype, \"setBeans\", null);\n    EnterpriseRowModel = __decorate([\n        ag_grid_1.Bean('rowModel')\n    ], EnterpriseRowModel);\n    return EnterpriseRowModel;\n}(ag_grid_1.BeanStub));\nexports.EnterpriseRowModel = EnterpriseRowModel;\n",null]}