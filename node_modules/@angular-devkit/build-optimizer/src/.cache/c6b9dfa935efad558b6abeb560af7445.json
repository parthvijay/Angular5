{"remainingRequest":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowModels/enterprise/enterpriseCache.js","dependencies":[{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowModels/enterprise/enterpriseCache.js","mtime":1523957359000},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/cache-loader/dist/cjs.js","mtime":1525383502481},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// ag-grid-enterprise v17.1.1\n\"use strict\";\nvar __extends = /*@__PURE__*/ require(\"tslib\").__extends;\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nvar __param = /*@__PURE__*/ require(\"tslib\").__param;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ag_grid_1 = require(\"ag-grid\");\nvar enterpriseBlock_1 = require(\"./enterpriseBlock\");\nvar EnterpriseCache = /*@__PURE__*/ (function (_super) {\n    __extends(EnterpriseCache, _super);\n    function EnterpriseCache(cacheParams, parentRowNode) {\n        var _this = _super.call(this, cacheParams) || this;\n        // this will always be zero for the top level cache only,\n        // all the other ones change as the groups open and close\n        _this.displayIndexStart = 0;\n        _this.displayIndexEnd = 0; // not sure if setting this one to zero is necessary\n        _this.cacheTop = 0;\n        _this.blockHeights = {};\n        _this.parentRowNode = parentRowNode;\n        return _this;\n    }\n    EnterpriseCache.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('EnterpriseCache');\n    };\n    EnterpriseCache.prototype.init = function () {\n        _super.prototype.init.call(this);\n    };\n    EnterpriseCache.prototype.getRowBounds = function (index) {\n        var _this = this;\n        this.logger.log(\"getRowBounds(\" + index + \")\");\n        // we return null if row not found\n        var result;\n        var blockFound = false;\n        var lastBlock;\n        this.forEachBlockInOrder(function (block) {\n            if (blockFound)\n                return;\n            if (block.isDisplayIndexInBlock(index)) {\n                result = block.getRowBounds(index, _this.getVirtualRowCount());\n                blockFound = true;\n            }\n            else if (block.isBlockBefore(index)) {\n                lastBlock = block;\n            }\n        });\n        if (!blockFound) {\n            var nextRowTop = void 0;\n            var nextRowIndex = void 0;\n            if (lastBlock) {\n                nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n                nextRowIndex = lastBlock.getDisplayIndexEnd();\n            }\n            else {\n                nextRowTop = this.cacheTop;\n                nextRowIndex = this.displayIndexStart;\n            }\n            var rowsBetween = index - nextRowIndex;\n            result = {\n                rowHeight: this.cacheParams.rowHeight,\n                rowTop: nextRowTop + rowsBetween * this.cacheParams.rowHeight\n            };\n        }\n        //TODO: what about purged blocks\n        this.logger.log(\"getRowBounds(\" + index + \"), result = \" + result);\n        return result;\n    };\n    EnterpriseCache.prototype.destroyBlock = function (block) {\n        _super.prototype.destroyBlock.call(this, block);\n    };\n    EnterpriseCache.prototype.getRowIndexAtPixel = function (pixel) {\n        var _this = this;\n        this.logger.log(\"getRowIndexAtPixel(\" + pixel + \")\");\n        // we return null if row not found\n        var result;\n        var blockFound = false;\n        var lastBlock;\n        this.forEachBlockInOrder(function (block) {\n            if (blockFound)\n                return;\n            if (block.isPixelInRange(pixel)) {\n                result = block.getRowIndexAtPixel(pixel, _this.getVirtualRowCount());\n                blockFound = true;\n            }\n            else if (block.getBlockTop() > pixel) {\n                lastBlock = block;\n            }\n        });\n        if (!blockFound) {\n            var nextRowTop = void 0;\n            var nextRowIndex = void 0;\n            if (lastBlock) {\n                nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n                nextRowIndex = lastBlock.getDisplayIndexEnd();\n            }\n            else {\n                nextRowTop = this.cacheTop;\n                nextRowIndex = this.displayIndexStart;\n            }\n            var pixelsBetween = pixel - nextRowTop;\n            var rowsBetween = (pixelsBetween / this.cacheParams.rowHeight) | 0;\n            result = nextRowIndex + rowsBetween;\n        }\n        var lastAllowedIndex = this.getDisplayIndexEnd() - 1;\n        if (result > lastAllowedIndex) {\n            result = lastAllowedIndex;\n        }\n        //TODO: purged\n        this.logger.log(\"getRowIndexAtPixel(\" + pixel + \") result = \" + result);\n        return result;\n    };\n    EnterpriseCache.prototype.clearRowTops = function () {\n        var _this = this;\n        this.forEachBlockInOrder(function (block) { return block.clearRowTops(_this.getVirtualRowCount()); });\n    };\n    EnterpriseCache.prototype.setDisplayIndexes = function (displayIndexSeq, nextRowTop) {\n        var _this = this;\n        this.displayIndexStart = displayIndexSeq.peek();\n        this.cacheTop = nextRowTop.value;\n        var lastBlockId = -1;\n        this.forEachBlockInOrder(function (currentBlock, blockId) {\n            // if we skipped blocks, then we need to skip the row indexes. we assume that all missing\n            // blocks are made up of closed RowNodes only (if they were groups), as we never expire from\n            // the cache if any row nodes are open.\n            var blocksSkippedCount = blockId - lastBlockId - 1;\n            var rowsSkippedCount = blocksSkippedCount * _this.cacheParams.blockSize;\n            if (rowsSkippedCount > 0) {\n                displayIndexSeq.skip(rowsSkippedCount);\n            }\n            for (var i = 1; i <= blocksSkippedCount; i++) {\n                var blockToAddId = blockId - i;\n                if (ag_grid_1._.exists(_this.blockHeights[blockToAddId])) {\n                    nextRowTop.value += _this.blockHeights[blockToAddId];\n                }\n                else {\n                    nextRowTop.value += _this.cacheParams.blockSize * _this.cacheParams.rowHeight;\n                }\n            }\n            lastBlockId = blockId;\n            currentBlock.setDisplayIndexes(displayIndexSeq, _this.getVirtualRowCount(), nextRowTop);\n            _this.blockHeights[blockId] = currentBlock.getBlockHeight();\n        });\n        // if any blocks missing at the end, need to increase the row index for them also\n        // eg if block size = 10, we have total rows of 25 (indexes 0 .. 24), but first 2 blocks loaded (because\n        // last row was ejected from cache), then:\n        // lastVisitedRow = 19, virtualRowCount = 25, rows not accounted for = 5 (24 - 19)\n        var lastVisitedRow = ((lastBlockId + 1) * this.cacheParams.blockSize) - 1;\n        var rowCount = this.getVirtualRowCount();\n        var rowsNotAccountedFor = rowCount - lastVisitedRow - 1;\n        if (rowsNotAccountedFor > 0) {\n            displayIndexSeq.skip(rowsNotAccountedFor);\n            nextRowTop.value += rowsNotAccountedFor * this.cacheParams.rowHeight;\n        }\n        this.displayIndexEnd = displayIndexSeq.peek();\n        this.cacheHeight = nextRowTop.value - this.cacheTop;\n    };\n    // gets called in a) init() above and b) by the grid\n    EnterpriseCache.prototype.getRow = function (displayRowIndex) {\n        var _this = this;\n        // this can happen if asking for a row that doesn't exist in the model,\n        // eg if a cell range is selected, and the user filters so rows no longer\n        // exist\n        if (!this.isDisplayIndexInCache(displayRowIndex)) {\n            return null;\n        }\n        // if we have the block, then this is the block\n        var block = null;\n        // this is the last block that we have BEFORE the right block\n        var beforeBlock = null;\n        this.forEachBlockInOrder(function (currentBlock) {\n            if (currentBlock.isDisplayIndexInBlock(displayRowIndex)) {\n                block = currentBlock;\n            }\n            else if (currentBlock.isBlockBefore(displayRowIndex)) {\n                // this will get assigned many times, but the last time will\n                // be the closest block to the required block that is BEFORE\n                beforeBlock = currentBlock;\n            }\n        });\n        // if block not found, we need to load it\n        if (ag_grid_1._.missing(block)) {\n            var blockNumber = void 0;\n            var displayIndexStart_1;\n            var nextRowTop = void 0;\n            // because missing blocks are always fully closed, we can work out\n            // the start index of the block we want by hopping from the closest block,\n            // as we know the row count in closed blocks is equal to the page size\n            if (beforeBlock) {\n                blockNumber = beforeBlock.getBlockNumber() + 1;\n                displayIndexStart_1 = beforeBlock.getDisplayIndexEnd();\n                nextRowTop = beforeBlock.getBlockHeight() + beforeBlock.getBlockTop();\n                var isInRange = function () {\n                    return displayRowIndex >= displayIndexStart_1 && displayRowIndex < (displayIndexStart_1 + _this.cacheParams.blockSize);\n                };\n                while (!isInRange()) {\n                    displayIndexStart_1 += this.cacheParams.blockSize;\n                    var cachedBlockHeight = this.blockHeights[blockNumber];\n                    if (ag_grid_1._.exists(cachedBlockHeight)) {\n                        nextRowTop += cachedBlockHeight;\n                    }\n                    else {\n                        nextRowTop += this.cacheParams.rowHeight * this.cacheParams.blockSize;\n                    }\n                    blockNumber++;\n                }\n            }\n            else {\n                var localIndex = displayRowIndex - this.displayIndexStart;\n                blockNumber = Math.floor(localIndex / this.cacheParams.blockSize);\n                displayIndexStart_1 = this.displayIndexStart + (blockNumber * this.cacheParams.blockSize);\n                nextRowTop = this.cacheTop + (blockNumber * this.cacheParams.blockSize * this.cacheParams.rowHeight);\n            }\n            block = this.createBlock(blockNumber, displayIndexStart_1, { value: nextRowTop });\n            this.logger.log(\"block missing, rowIndex = \" + displayRowIndex + \", creating #\" + blockNumber + \", displayIndexStart = \" + displayIndexStart_1);\n        }\n        var rowNode = block.getRow(displayRowIndex);\n        return rowNode;\n    };\n    EnterpriseCache.prototype.createBlock = function (blockNumber, displayIndex, nextRowTop) {\n        var newBlock = new enterpriseBlock_1.EnterpriseBlock(blockNumber, this.parentRowNode, this.cacheParams, this);\n        this.context.wireBean(newBlock);\n        var displayIndexSequence = new ag_grid_1.NumberSequence(displayIndex);\n        newBlock.setDisplayIndexes(displayIndexSequence, this.getVirtualRowCount(), nextRowTop);\n        this.postCreateBlock(newBlock);\n        return newBlock;\n    };\n    EnterpriseCache.prototype.getDisplayIndexEnd = function () {\n        return this.displayIndexEnd;\n    };\n    EnterpriseCache.prototype.isDisplayIndexInCache = function (displayIndex) {\n        if (this.getVirtualRowCount() === 0) {\n            return false;\n        }\n        return displayIndex >= this.displayIndexStart && displayIndex < this.displayIndexEnd;\n    };\n    EnterpriseCache.prototype.getChildCache = function (keys) {\n        var _this = this;\n        if (ag_grid_1._.missingOrEmpty(keys)) {\n            return this;\n        }\n        var nextKey = keys[0];\n        var nextEnterpriseCache = null;\n        this.forEachBlockInOrder(function (block) {\n            // callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number\n            block.forEachNodeShallow(function (rowNode) {\n                if (rowNode.key === nextKey) {\n                    nextEnterpriseCache = rowNode.childrenCache;\n                }\n            }, new ag_grid_1.NumberSequence(), _this.getVirtualRowCount());\n        });\n        if (nextEnterpriseCache) {\n            var keyListForNextLevel = keys.slice(1, keys.length);\n            return nextEnterpriseCache.getChildCache(keyListForNextLevel);\n        }\n        else {\n            return null;\n        }\n    };\n    EnterpriseCache.prototype.isPixelInRange = function (pixel) {\n        if (this.getVirtualRowCount() === 0) {\n            return false;\n        }\n        return pixel >= this.cacheTop && pixel < (this.cacheTop + this.cacheHeight);\n    };\n    __decorate([\n        ag_grid_1.Autowired('eventService'),\n        __metadata(\"design:type\", ag_grid_1.EventService)\n    ], EnterpriseCache.prototype, \"eventService\", void 0);\n    __decorate([\n        ag_grid_1.Autowired('context'),\n        __metadata(\"design:type\", ag_grid_1.Context)\n    ], EnterpriseCache.prototype, \"context\", void 0);\n    __decorate([\n        __param(0, ag_grid_1.Qualifier('loggerFactory')),\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", [ag_grid_1.LoggerFactory]),\n        __metadata(\"design:returntype\", void 0)\n    ], EnterpriseCache.prototype, \"setBeans\", null);\n    __decorate([\n        ag_grid_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], EnterpriseCache.prototype, \"init\", null);\n    return EnterpriseCache;\n}(ag_grid_1.RowNodeCache));\nexports.EnterpriseCache = EnterpriseCache;\n",null]}