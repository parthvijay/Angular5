{"remainingRequest":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowStages/groupStage.js","dependencies":[{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowStages/groupStage.js","mtime":1523957359000},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/cache-loader/dist/cjs.js","mtime":1525383502481},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// ag-grid-enterprise v17.1.1\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar main_1 = require(\"ag-grid/main\");\nvar GroupStage = /*@__PURE__*/ (function () {\n    function GroupStage() {\n        // we use a sequence variable so that each time we do a grouping, we don't\n        // reuse the ids - otherwise the rowRenderer will confuse rowNodes between redraws\n        // when it tries to animate between rows. we set to -1 as others row id 0 will be shared\n        // with the other rows.\n        this.groupIdSequence = new main_1.NumberSequence(1);\n    }\n    // when grouping, these items are of note:\n    // rowNode.parent: RowNode: set to the parent\n    // rowNode.childrenAfterGroup: RowNode[] = the direct children of this group\n    // rowNode.childrenMapped: string=>RowNode = children mapped by group key (when groups) or an empty map if leaf group (this is then used by pivot)\n    // for leaf groups, rowNode.childrenAfterGroup = rowNode.allLeafChildren;\n    GroupStage.prototype.postConstruct = function () {\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n        if (this.usingTreeData) {\n            this.getDataPath = this.gridOptionsWrapper.getDataPathFunc();\n            if (main_1._.missing(this.getDataPath)) {\n                console.warn('ag-Grid: property usingTreeData=true, but you did not provide getDataPath function, please provide getDataPath function if using tree data.');\n            }\n        }\n    };\n    GroupStage.prototype.execute = function (params) {\n        var details = this.createGroupingDetails(params);\n        if (details.transaction) {\n            this.handleTransaction(details);\n        }\n        else {\n            this.shotgunResetEverything(details);\n        }\n        this.sortGroupsWithComparator(details.rootNode);\n        this.selectableService.updateSelectableAfterGrouping(details.rootNode);\n    };\n    GroupStage.prototype.createGroupingDetails = function (params) {\n        var rowNode = params.rowNode, changedPath = params.changedPath, rowNodeTransaction = params.rowNodeTransaction, rowNodeOrder = params.rowNodeOrder;\n        var groupedCols = this.usingTreeData ? null : this.columnController.getRowGroupColumns();\n        var isGrouping = this.usingTreeData || groupedCols.length > 0;\n        var usingTransaction = isGrouping && main_1._.exists(rowNodeTransaction);\n        var details = {\n            // someone complained that the parent attribute was causing some change detection\n            // to break is some angular add-on - which i never used. taking the parent out breaks\n            // a cyclic dependency, hence this flag got introduced.\n            includeParents: !this.gridOptionsWrapper.isSuppressParentsInRowNodes(),\n            expandByDefault: this.gridOptionsWrapper.isGroupSuppressRow() ?\n                -1 : this.gridOptionsWrapper.getGroupDefaultExpanded(),\n            groupedCols: groupedCols,\n            rootNode: rowNode,\n            pivotMode: this.columnController.isPivotMode(),\n            groupedColCount: this.usingTreeData ? 0 : groupedCols.length,\n            rowNodeOrder: rowNodeOrder,\n            // important not to do transaction if we are not grouping, as otherwise the 'insert index' is ignored.\n            // ie, if not grouping, then we just want to shotgun so the rootNode.allLeafChildren gets copied\n            // to rootNode.childrenAfterGroup and maintaining order (as delta transaction misses the order).\n            transaction: usingTransaction ? rowNodeTransaction : null,\n            // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway\n            changedPath: changedPath\n        };\n        return details;\n    };\n    GroupStage.prototype.handleTransaction = function (details) {\n        var tran = details.transaction;\n        if (tran.add) {\n            this.insertNodes(tran.add, details);\n        }\n        if (tran.update) {\n            this.moveNodesInWrongPath(tran.update, details);\n        }\n        if (tran.remove) {\n            this.removeNodes(tran.remove, details);\n        }\n        if (details.rowNodeOrder) {\n            this.recursiveSortChildren(details.rootNode, details);\n        }\n    };\n    // this is used when doing delta updates, eg Redux, keeps nodes in right order\n    GroupStage.prototype.recursiveSortChildren = function (node, details) {\n        var _this = this;\n        main_1._.sortRowNodesByOrder(node.childrenAfterGroup, details.rowNodeOrder);\n        node.childrenAfterGroup.forEach(function (childNode) {\n            if (childNode.childrenAfterGroup) {\n                _this.recursiveSortChildren(childNode, details);\n            }\n        });\n    };\n    GroupStage.prototype.sortGroupsWithComparator = function (rootNode) {\n        // we don't do group sorting for tree data\n        if (this.usingTreeData) {\n            return;\n        }\n        var comparator = this.gridOptionsWrapper.getDefaultGroupSortComparator();\n        if (main_1._.exists(comparator)) {\n            recursiveSort(rootNode);\n        }\n        function recursiveSort(rowNode) {\n            var doSort = main_1._.exists(rowNode.childrenAfterGroup) &&\n                // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)\n                !rowNode.leafGroup;\n            if (doSort) {\n                rowNode.childrenAfterGroup.sort(comparator);\n                rowNode.childrenAfterGroup.forEach(function (childNode) { return recursiveSort(childNode); });\n            }\n        }\n    };\n    GroupStage.prototype.getExistingPathForNode = function (node, details) {\n        var res = [];\n        // when doing tree data, the node is part of the path,\n        // but when doing grid grouping, the node is not part of the path so we start with the parent.\n        var pointer = this.usingTreeData ? node : node.parent;\n        while (pointer !== details.rootNode) {\n            res.push({\n                key: pointer.key,\n                rowGroupColumn: pointer.rowGroupColumn,\n                field: pointer.field\n            });\n            pointer = pointer.parent;\n        }\n        res.reverse();\n        return res;\n    };\n    GroupStage.prototype.moveNodesInWrongPath = function (childNodes, details) {\n        var _this = this;\n        childNodes.forEach(function (childNode) {\n            // we add node, even if parent has not changed, as the data could have\n            // changed, hence aggregations will be wrong\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(childNode.parent);\n            }\n            var infoToKeyMapper = function (item) { return item.key; };\n            var oldPath = _this.getExistingPathForNode(childNode, details).map(infoToKeyMapper);\n            var newPath = _this.getGroupInfo(childNode, details).map(infoToKeyMapper);\n            var nodeInCorrectPath = main_1._.compareArrays(oldPath, newPath);\n            if (!nodeInCorrectPath) {\n                _this.moveNode(childNode, details);\n            }\n        });\n    };\n    GroupStage.prototype.moveNode = function (childNode, details) {\n        this.removeOneNode(childNode, details);\n        this.insertOneNode(childNode, details);\n        // hack - if we didn't do this, then renaming a tree item (ie changing rowNode.key) wouldn't get\n        // refreshed into the gui.\n        // this is needed to kick off the event that rowComp listens to for refresh. this in turn\n        // then will get each cell in the row to refresh - which is what we need as we don't know which\n        // columns will be displaying the rowNode.key info.\n        childNode.setData(childNode.data);\n        // we add both old and new parents to changed path, as both will need to be refreshed.\n        // we already added the old parent (in calling method), so just add the new parent here\n        if (details.changedPath.isActive()) {\n            var newParent = childNode.parent;\n            details.changedPath.addParentNode(newParent);\n        }\n    };\n    GroupStage.prototype.removeNodes = function (leafRowNodes, details) {\n        var _this = this;\n        leafRowNodes.forEach(function (leafToRemove) {\n            _this.removeOneNode(leafToRemove, details);\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(leafToRemove.parent);\n            }\n        });\n    };\n    GroupStage.prototype.removeOneNode = function (childNode, details) {\n        var _this = this;\n        // utility func to execute once on each parent node\n        var forEachParentGroup = function (callback) {\n            var pointer = childNode.parent;\n            while (pointer !== details.rootNode) {\n                callback(pointer);\n                pointer = pointer.parent;\n            }\n        };\n        // remove leaf from direct parent\n        this.removeFromParent(childNode);\n        // remove from allLeafChildren\n        forEachParentGroup(function (parentNode) { return main_1._.removeFromArray(parentNode.allLeafChildren, childNode); });\n        // if not group, and children are present, need to move children to a group.\n        // otherwise if no children, we can just remove without replacing.\n        var replaceWithGroup = childNode.hasChildren();\n        if (replaceWithGroup) {\n            var oldPath = this.getExistingPathForNode(childNode, details);\n            // because we just removed the userGroup, this will always return new support group\n            var newGroupNode_1 = this.findParentForNode(childNode, oldPath, details);\n            // these properties are the ones that will be incorrect in the newly created group,\n            // so copy them form the old childNode\n            newGroupNode_1.expanded = childNode.expanded;\n            newGroupNode_1.allLeafChildren = childNode.allLeafChildren;\n            newGroupNode_1.childrenAfterGroup = childNode.childrenAfterGroup;\n            newGroupNode_1.childrenMapped = childNode.childrenMapped;\n            newGroupNode_1.childrenAfterGroup.forEach(function (rowNode) { return rowNode.parent = newGroupNode_1; });\n        }\n        // remove empty groups\n        forEachParentGroup(function (node) {\n            if (node.isEmptyFillerNode()) {\n                _this.removeFromParent(node);\n                // we remove selection on filler nodes here, as the selection would not be removed\n                // from the RowNodeManager, as filler nodes don't exist on teh RowNodeManager\n                node.setSelected(false);\n            }\n        });\n    };\n    GroupStage.prototype.removeFromParent = function (child) {\n        main_1._.removeFromArray(child.parent.childrenAfterGroup, child);\n        var mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);\n        child.parent.childrenMapped[mapKey] = undefined;\n        // this is important for transition, see rowComp removeFirstPassFuncs. when doing animation and\n        // remove, if rowTop is still present, the rowComp thinks it's just moved position.\n        child.setRowTop(null);\n    };\n    GroupStage.prototype.addToParent = function (child, parent) {\n        var mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);\n        parent.childrenMapped[mapKey] = child;\n        parent.childrenAfterGroup.push(child);\n    };\n    GroupStage.prototype.shotgunResetEverything = function (details) {\n        // because we are not creating the root node each time, we have the logic\n        // here to change leafGroup once.\n        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n        details.rootNode.leafGroup = this.usingTreeData ? false : details.groupedCols.length === 0;\n        // we are going everything from scratch, so reset childrenAfterGroup and childrenMapped from the rootNode\n        details.rootNode.childrenAfterGroup = [];\n        details.rootNode.childrenMapped = {};\n        this.insertNodes(details.rootNode.allLeafChildren, details);\n    };\n    GroupStage.prototype.insertNodes = function (newRowNodes, details) {\n        var _this = this;\n        newRowNodes.forEach(function (rowNode) {\n            _this.insertOneNode(rowNode, details);\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(rowNode.parent);\n            }\n        });\n    };\n    GroupStage.prototype.insertOneNode = function (childNode, details) {\n        var path = this.getGroupInfo(childNode, details);\n        var parentGroup = this.findParentForNode(childNode, path, details);\n        if (!parentGroup.group) {\n            console.warn(\"ag-Grid: duplicate group keys for row data, keys should be unique\", [parentGroup.data, childNode.data]);\n        }\n        if (this.usingTreeData) {\n            this.swapGroupWithUserNode(parentGroup, childNode);\n        }\n        else {\n            childNode.parent = parentGroup;\n            childNode.level = path.length;\n            parentGroup.childrenAfterGroup.push(childNode);\n        }\n    };\n    GroupStage.prototype.findParentForNode = function (childNode, path, details) {\n        var _this = this;\n        var nextNode = details.rootNode;\n        path.forEach(function (groupInfo, level) {\n            nextNode = _this.getOrCreateNextNode(nextNode, groupInfo, level, details);\n            // node gets added to all group nodes.\n            // note: we do not add to rootNode here, as the rootNode is the master list of rowNodes\n            nextNode.allLeafChildren.push(childNode);\n        });\n        return nextNode;\n    };\n    GroupStage.prototype.swapGroupWithUserNode = function (fillerGroup, userGroup) {\n        userGroup.parent = fillerGroup.parent;\n        userGroup.key = fillerGroup.key;\n        userGroup.field = fillerGroup.field;\n        userGroup.groupData = fillerGroup.groupData;\n        userGroup.level = fillerGroup.level;\n        userGroup.expanded = fillerGroup.expanded;\n        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n        userGroup.leafGroup = fillerGroup.leafGroup;\n        // always null for userGroups, as row grouping is not allowed when doing tree data\n        userGroup.rowGroupIndex = fillerGroup.rowGroupIndex;\n        userGroup.allLeafChildren = fillerGroup.allLeafChildren;\n        userGroup.childrenAfterGroup = fillerGroup.childrenAfterGroup;\n        userGroup.childrenMapped = fillerGroup.childrenMapped;\n        this.removeFromParent(fillerGroup);\n        userGroup.childrenAfterGroup.forEach(function (rowNode) { return rowNode.parent = userGroup; });\n        this.addToParent(userGroup, fillerGroup.parent);\n    };\n    GroupStage.prototype.getOrCreateNextNode = function (parentGroup, groupInfo, level, details) {\n        var mapKey = this.getChildrenMappedKey(groupInfo.key, groupInfo.rowGroupColumn);\n        var nextNode = parentGroup.childrenMapped[mapKey];\n        if (!nextNode) {\n            nextNode = this.createGroup(groupInfo, parentGroup, level, details);\n            // attach the new group to the parent\n            this.addToParent(nextNode, parentGroup);\n        }\n        return nextNode;\n    };\n    GroupStage.prototype.createGroup = function (groupInfo, parent, level, details) {\n        var _this = this;\n        var groupNode = new main_1.RowNode();\n        this.context.wireBean(groupNode);\n        groupNode.group = true;\n        groupNode.field = groupInfo.field;\n        groupNode.rowGroupColumn = groupInfo.rowGroupColumn;\n        groupNode.groupData = {};\n        var groupDisplayCols = this.columnController.getGroupDisplayColumns();\n        groupDisplayCols.forEach(function (col) {\n            // newGroup.rowGroupColumn=null when working off GroupInfo, and we always display the group in the group column\n            // if rowGroupColumn is present, then it's grid row grouping and we only include if configuration says so\n            var displayGroupForCol = _this.usingTreeData || col.isRowGroupDisplayed(groupNode.rowGroupColumn.getId());\n            if (displayGroupForCol) {\n                groupNode.groupData[col.getColId()] = groupInfo.key;\n            }\n        });\n        // we use negative number for the ids of the groups, this makes sure we don't clash with the\n        // id's of the leaf nodes.\n        groupNode.id = (this.groupIdSequence.next() * -1).toString();\n        groupNode.key = groupInfo.key;\n        groupNode.level = level;\n        groupNode.leafGroup = this.usingTreeData ? false : level === (details.groupedColCount - 1);\n        // if doing pivoting, then the leaf group is never expanded,\n        // as we do not show leaf rows\n        if (details.pivotMode && groupNode.leafGroup) {\n            groupNode.expanded = false;\n        }\n        else {\n            groupNode.expanded = this.isExpanded(details.expandByDefault, level);\n        }\n        groupNode.allLeafChildren = [];\n        // why is this done here? we are not updating the children could as we go,\n        // i suspect this is updated in the filter stage\n        groupNode.setAllChildrenCount(0);\n        groupNode.rowGroupIndex = this.usingTreeData ? null : level;\n        groupNode.childrenAfterGroup = [];\n        groupNode.childrenMapped = {};\n        groupNode.parent = details.includeParents ? parent : null;\n        return groupNode;\n    };\n    GroupStage.prototype.getChildrenMappedKey = function (key, rowGroupColumn) {\n        if (rowGroupColumn) {\n            // grouping by columns\n            return rowGroupColumn.getId() + '-' + key;\n        }\n        else {\n            // tree data - we don't have rowGroupColumns\n            return key;\n        }\n    };\n    GroupStage.prototype.isExpanded = function (expandByDefault, level) {\n        if (expandByDefault === -1) {\n            return true;\n        }\n        else {\n            return level < expandByDefault;\n        }\n    };\n    GroupStage.prototype.getGroupInfo = function (rowNode, details) {\n        if (this.usingTreeData) {\n            return this.getGroupInfoFromCallback(rowNode);\n        }\n        else {\n            return this.getGroupInfoFromGroupColumns(rowNode, details);\n        }\n    };\n    GroupStage.prototype.getGroupInfoFromCallback = function (rowNode) {\n        var keys = this.getDataPath(rowNode.data);\n        if (keys === null || keys === undefined || keys.length === 0) {\n            main_1._.doOnce(function () { return console.warn(\"getDataPath() should not return an empty path for data\", rowNode.data); }, 'groupStage.getGroupInfoFromCallback');\n        }\n        var groupInfoMapper = function (key) { return ({ key: key, field: null, rowGroupColumn: null }); };\n        return keys ? keys.map(groupInfoMapper) : [];\n    };\n    GroupStage.prototype.getGroupInfoFromGroupColumns = function (rowNode, details) {\n        var _this = this;\n        var res = [];\n        details.groupedCols.forEach(function (groupCol) {\n            var key = _this.valueService.getKeyForNode(groupCol, rowNode);\n            var keyExists = key !== null && key !== undefined;\n            // unbalanced tree and pivot mode don't work together - not because of the grid, it doesn't make\n            // mathematical sense as you are building up a cube. so if pivot mode, we put in a blank key where missing.\n            // this keeps the tree balanced and hence can be represented as a group.\n            if (details.pivotMode && !keyExists) {\n                key = ' ';\n                keyExists = true;\n            }\n            if (keyExists) {\n                var item = {\n                    key: key,\n                    field: groupCol.getColDef().field,\n                    rowGroupColumn: groupCol\n                };\n                res.push(item);\n            }\n        });\n        return res;\n    };\n    __decorate([\n        main_1.Autowired('selectionController'),\n        __metadata(\"design:type\", main_1.SelectionController)\n    ], GroupStage.prototype, \"selectionController\", void 0);\n    __decorate([\n        main_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", main_1.GridOptionsWrapper)\n    ], GroupStage.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        main_1.Autowired('columnController'),\n        __metadata(\"design:type\", main_1.ColumnController)\n    ], GroupStage.prototype, \"columnController\", void 0);\n    __decorate([\n        main_1.Autowired('selectableService'),\n        __metadata(\"design:type\", main_1.SelectableService)\n    ], GroupStage.prototype, \"selectableService\", void 0);\n    __decorate([\n        main_1.Autowired('valueService'),\n        __metadata(\"design:type\", main_1.ValueService)\n    ], GroupStage.prototype, \"valueService\", void 0);\n    __decorate([\n        main_1.Autowired('eventService'),\n        __metadata(\"design:type\", main_1.EventService)\n    ], GroupStage.prototype, \"eventService\", void 0);\n    __decorate([\n        main_1.Autowired('context'),\n        __metadata(\"design:type\", main_1.Context)\n    ], GroupStage.prototype, \"context\", void 0);\n    __decorate([\n        main_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], GroupStage.prototype, \"postConstruct\", null);\n    GroupStage = __decorate([\n        main_1.Bean('groupStage')\n    ], GroupStage);\n    return GroupStage;\n}());\nexports.GroupStage = GroupStage;\n",null]}