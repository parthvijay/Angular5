{"remainingRequest":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowStages/pivotStage.js","dependencies":[{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowStages/pivotStage.js","mtime":1523957359000},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/cache-loader/dist/cjs.js","mtime":1525383502481},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// ag-grid-enterprise v17.1.1\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar main_1 = require(\"ag-grid/main\");\nvar pivotColDefService_1 = require(\"./pivotColDefService\");\nvar PivotStage = /*@__PURE__*/ (function () {\n    function PivotStage() {\n        this.uniqueValues = {};\n    }\n    PivotStage.prototype.execute = function (params) {\n        var rootNode = params.rowNode;\n        var changedPath = params.changedPath;\n        if (this.columnController.isPivotActive()) {\n            this.executePivotOn(rootNode, changedPath);\n        }\n        else {\n            this.executePivotOff(changedPath);\n        }\n    };\n    PivotStage.prototype.executePivotOff = function (changedPath) {\n        this.aggregationColumnsHashLastTime = null;\n        this.uniqueValues = {};\n        if (this.columnController.isSecondaryColumnsPresent()) {\n            this.columnController.setSecondaryColumns(null, \"rowModelUpdated\");\n            changedPath.setInactive();\n        }\n    };\n    PivotStage.prototype.executePivotOn = function (rootNode, changedPath) {\n        var uniqueValues = this.bucketUpRowNodes(rootNode);\n        var uniqueValuesChanged = this.setUniqueValues(uniqueValues);\n        var aggregationColumns = this.columnController.getValueColumns();\n        var aggregationColumnsHash = aggregationColumns.map(function (column) { return column.getId(); }).join('#');\n        var aggregationFuncsHash = aggregationColumns.map(function (column) { return column.getAggFunc().toString(); }).join('#');\n        var aggregationColumnsChanged = this.aggregationColumnsHashLastTime !== aggregationColumnsHash;\n        var aggregationFuncsChanged = this.aggregationFuncsHashLastTime !== aggregationFuncsHash;\n        this.aggregationColumnsHashLastTime = aggregationColumnsHash;\n        this.aggregationFuncsHashLastTime = aggregationFuncsHash;\n        if (uniqueValuesChanged || aggregationColumnsChanged || aggregationFuncsChanged) {\n            var result = this.pivotColDefService.createPivotColumnDefs(this.uniqueValues);\n            this.pivotColumnGroupDefs = result.pivotColumnGroupDefs;\n            this.pivotColumnDefs = result.pivotColumnDefs;\n            this.columnController.setSecondaryColumns(this.pivotColumnGroupDefs, \"rowModelUpdated\");\n            // because the secondary columns have changed, then the aggregation needs to visit the whole\n            // tree again, so we make the changedPath not active, to force aggregation to visit all paths.\n            changedPath.setInactive();\n        }\n    };\n    PivotStage.prototype.setUniqueValues = function (newValues) {\n        var json1 = JSON.stringify(newValues);\n        var json2 = JSON.stringify(this.uniqueValues);\n        var uniqueValuesChanged = json1 !== json2;\n        // we only continue the below if the unique values are different, as otherwise\n        // the result will be the same as the last time we did it\n        if (uniqueValuesChanged) {\n            this.uniqueValues = newValues;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // returns true if values were different\n    PivotStage.prototype.bucketUpRowNodes = function (rootNode) {\n        var _this = this;\n        // accessed from inside inner function\n        var uniqueValues = {};\n        // finds all leaf groups and calls mapRowNode with it\n        var recursivelySearchForLeafNodes = function (rowNode) {\n            if (rowNode.leafGroup) {\n                _this.bucketRowNode(rowNode, uniqueValues);\n            }\n            else {\n                rowNode.childrenAfterFilter.forEach(function (child) {\n                    recursivelySearchForLeafNodes(child);\n                });\n            }\n        };\n        recursivelySearchForLeafNodes(rootNode);\n        return uniqueValues;\n    };\n    PivotStage.prototype.bucketRowNode = function (rowNode, uniqueValues) {\n        var pivotColumns = this.columnController.getPivotColumns();\n        if (pivotColumns.length === 0) {\n            rowNode.childrenMapped = null;\n            return;\n        }\n        rowNode.childrenMapped = this.bucketChildren(rowNode.childrenAfterFilter, pivotColumns, 0, uniqueValues);\n    };\n    PivotStage.prototype.bucketChildren = function (children, pivotColumns, pivotIndex, uniqueValues) {\n        var _this = this;\n        var mappedChildren = {};\n        var pivotColumn = pivotColumns[pivotIndex];\n        // map the children out based on the pivot column\n        children.forEach(function (child) {\n            var key = _this.valueService.getKeyForNode(pivotColumn, child);\n            if (main_1.Utils.missing(key)) {\n                key = '';\n            }\n            if (!uniqueValues[key]) {\n                uniqueValues[key] = {};\n            }\n            if (!mappedChildren[key]) {\n                mappedChildren[key] = [];\n            }\n            mappedChildren[key].push(child);\n        });\n        // if it's the last pivot column, return as is, otherwise go one level further in the map\n        if (pivotIndex === pivotColumns.length - 1) {\n            return mappedChildren;\n        }\n        else {\n            var result_1 = {};\n            main_1.Utils.iterateObject(mappedChildren, function (key, value) {\n                result_1[key] = _this.bucketChildren(value, pivotColumns, pivotIndex + 1, uniqueValues[key]);\n            });\n            return result_1;\n        }\n    };\n    PivotStage.prototype.getPivotColumnDefs = function () {\n        return this.pivotColumnDefs;\n    };\n    __decorate([\n        main_1.Autowired('rowModel'),\n        __metadata(\"design:type\", Object)\n    ], PivotStage.prototype, \"rowModel\", void 0);\n    __decorate([\n        main_1.Autowired('valueService'),\n        __metadata(\"design:type\", main_1.ValueService)\n    ], PivotStage.prototype, \"valueService\", void 0);\n    __decorate([\n        main_1.Autowired('columnController'),\n        __metadata(\"design:type\", main_1.ColumnController)\n    ], PivotStage.prototype, \"columnController\", void 0);\n    __decorate([\n        main_1.Autowired('eventService'),\n        __metadata(\"design:type\", main_1.EventService)\n    ], PivotStage.prototype, \"eventService\", void 0);\n    __decorate([\n        main_1.Autowired('pivotColDefService'),\n        __metadata(\"design:type\", pivotColDefService_1.PivotColDefService)\n    ], PivotStage.prototype, \"pivotColDefService\", void 0);\n    PivotStage = __decorate([\n        main_1.Bean('pivotStage')\n    ], PivotStage);\n    return PivotStage;\n}());\nexports.PivotStage = PivotStage;\n",null]}