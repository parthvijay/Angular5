{"remainingRequest":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/clipboardService.js","dependencies":[{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/clipboardService.js","mtime":1523957359000},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/cache-loader/dist/cjs.js","mtime":1525383502481},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// ag-grid-enterprise v17.1.1\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar main_1 = require(\"ag-grid/main\");\nvar rangeController_1 = require(\"./rangeController\");\nvar ClipboardService = /*@__PURE__*/ (function () {\n    function ClipboardService() {\n    }\n    ClipboardService.prototype.init = function () {\n        this.logger = this.loggerFactory.create('ClipboardService');\n    };\n    ClipboardService.prototype.pasteFromClipboard = function () {\n        var _this = this;\n        this.logger.log('pasteFromClipboard');\n        this.executeOnTempElement(function (textArea) {\n            textArea.focus();\n        }, function (element) {\n            var data = element.value;\n            if (main_1.Utils.missingOrEmpty(data))\n                return;\n            var parsedData = _this.dataToArray(data);\n            var singleCellInClipboard = parsedData.length == 1 && parsedData[0].length == 1;\n            _this.rangeController.isMoreThanOneCell() && !singleCellInClipboard ?\n                _this.pasteToRange(data) : _this.pasteToSingleCell(data);\n        });\n    };\n    ClipboardService.prototype.pasteToRange = function (data) {\n        var _this = this;\n        var clipboardData = this.dataToArray(data);\n        // remove extra empty row which is inserted when clipboard has more than one row\n        if (clipboardData.length > 1)\n            clipboardData.pop();\n        var cellsToFlash = {};\n        var updatedRowNodes = [];\n        var updatedColumnIds = [];\n        // true if clipboard data can be evenly pasted into range, otherwise false\n        var abortRepeatingPasteIntoRows = this.rangeSize() % clipboardData.length != 0;\n        var indexOffset = 0, dataRowIndex = 0;\n        var rowCallback = function (currentRow, rowNode, columns, index) {\n            var atEndOfClipboardData = index - indexOffset >= clipboardData.length;\n            if (atEndOfClipboardData) {\n                if (abortRepeatingPasteIntoRows)\n                    return;\n                // increment offset and reset data index to repeat paste of data\n                indexOffset += dataRowIndex;\n                dataRowIndex = 0;\n            }\n            var currentRowData = clipboardData[index - indexOffset];\n            // otherwise we are not the first row, so copy\n            updatedRowNodes.push(rowNode);\n            columns.forEach(function (column, index) {\n                if (!column.isCellEditable(rowNode))\n                    return;\n                // ignore columns we don't have data for - happens when to range is bigger than copied data range\n                if (index >= currentRowData.length)\n                    return;\n                var firstRowValue = currentRowData[index];\n                var processCellFromClipboardFunc = _this.gridOptionsWrapper.getProcessCellFromClipboardFunc();\n                firstRowValue = _this.userProcessCell(rowNode, column, firstRowValue, processCellFromClipboardFunc, main_1.Constants.EXPORT_TYPE_DRAG_COPY);\n                _this.valueService.setValue(rowNode, column, firstRowValue);\n                var gridCellDef = { rowIndex: currentRow.rowIndex, floating: currentRow.floating, column: column };\n                var cellId = new main_1.GridCell(gridCellDef).createId();\n                cellsToFlash[cellId] = true;\n            });\n            ++dataRowIndex;\n        };\n        this.iterateActiveRanges(false, rowCallback);\n        this.rowRenderer.refreshCells({ rowNodes: updatedRowNodes, columns: updatedColumnIds });\n        this.dispatchFlashCells(cellsToFlash);\n        this.fireRowChanged(updatedRowNodes);\n    };\n    ClipboardService.prototype.pasteToSingleCell = function (data) {\n        if (main_1.Utils.missingOrEmpty(data)) {\n            return;\n        }\n        var focusedCell = this.focusedCellController.getFocusedCell();\n        if (!focusedCell) {\n            return;\n        }\n        var parsedData = this.dataToArray(data);\n        if (!parsedData) {\n            return;\n        }\n        // remove last row if empty, excel puts empty last row in\n        var lastLine = parsedData[parsedData.length - 1];\n        if (lastLine.length === 1 && lastLine[0] === '') {\n            main_1.Utils.removeFromArray(parsedData, lastLine);\n        }\n        var currentRow = new main_1.GridRow(focusedCell.rowIndex, focusedCell.floating);\n        var cellsToFlash = {};\n        var updatedRowNodes = [];\n        var updatedColumnIds = [];\n        var columnsToPasteInto = this.columnController.getDisplayedColumnsStartingAt(focusedCell.column);\n        var onlyOneCellInRange = parsedData.length === 1 && parsedData[0].length === 1;\n        if (onlyOneCellInRange) {\n            this.singleCellRange(parsedData, updatedRowNodes, currentRow, cellsToFlash, updatedColumnIds);\n        }\n        else {\n            this.multipleCellRange(parsedData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, updatedColumnIds, main_1.Constants.EXPORT_TYPE_CLIPBOARD);\n        }\n        // this is very heavy, should possibly just refresh the specific cells?\n        this.rowRenderer.refreshCells({ rowNodes: updatedRowNodes, columns: updatedColumnIds });\n        this.dispatchFlashCells(cellsToFlash);\n        this.focusedCellController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.floating, true);\n        this.fireRowChanged(updatedRowNodes);\n    };\n    ClipboardService.prototype.copyRangeDown = function () {\n        var _this = this;\n        if (this.rangeController.isEmpty()) {\n            return;\n        }\n        var cellsToFlash = {};\n        var firstRowValues = null;\n        var updatedRowNodes = [];\n        var updatedColumnIds = [];\n        var rowCallback = function (currentRow, rowNode, columns) {\n            // take reference of first row, this is the one we will be using to copy from\n            if (!firstRowValues) {\n                firstRowValues = [];\n                // two reasons for looping through columns\n                columns.forEach(function (column) {\n                    // reason 1 - to get the initial values to copy down\n                    var value = _this.valueService.getValue(column, rowNode);\n                    var processCellForClipboardFunc = _this.gridOptionsWrapper.getProcessCellForClipboardFunc();\n                    value = _this.userProcessCell(rowNode, column, value, processCellForClipboardFunc, main_1.Constants.EXPORT_TYPE_DRAG_COPY);\n                    firstRowValues.push(value);\n                    // reason 2 - to record the columnId for refreshing\n                    updatedColumnIds.push(column.getId());\n                });\n            }\n            else {\n                // otherwise we are not the first row, so copy\n                updatedRowNodes.push(rowNode);\n                columns.forEach(function (column, index) {\n                    if (!column.isCellEditable(rowNode)) {\n                        return;\n                    }\n                    var firstRowValue = firstRowValues[index];\n                    var processCellFromClipboardFunc = _this.gridOptionsWrapper.getProcessCellFromClipboardFunc();\n                    firstRowValue = _this.userProcessCell(rowNode, column, firstRowValue, processCellFromClipboardFunc, main_1.Constants.EXPORT_TYPE_DRAG_COPY);\n                    _this.valueService.setValue(rowNode, column, firstRowValue);\n                    var gridCellDef = { rowIndex: currentRow.rowIndex, floating: currentRow.floating, column: column };\n                    var cellId = new main_1.GridCell(gridCellDef).createId();\n                    cellsToFlash[cellId] = true;\n                });\n            }\n        };\n        this.iterateActiveRanges(true, rowCallback);\n        // this is very heavy, should possibly just refresh the specific cells?\n        this.rowRenderer.refreshCells({ rowNodes: updatedRowNodes, columns: updatedColumnIds });\n        this.dispatchFlashCells(cellsToFlash);\n        this.fireRowChanged(updatedRowNodes);\n    };\n    ClipboardService.prototype.fireRowChanged = function (rowNodes) {\n        var _this = this;\n        if (!this.gridOptionsWrapper.isFullRowEdit()) {\n            return;\n        }\n        rowNodes.forEach(function (rowNode) {\n            var event = {\n                type: main_1.Events.EVENT_ROW_VALUE_CHANGED,\n                node: rowNode,\n                data: rowNode.data,\n                rowIndex: rowNode.rowIndex,\n                rowPinned: rowNode.rowPinned,\n                context: _this.gridOptionsWrapper.getContext(),\n                api: _this.gridOptionsWrapper.getApi(),\n                columnApi: _this.gridOptionsWrapper.getColumnApi()\n            };\n            _this.eventService.dispatchEvent(event);\n        });\n    };\n    ClipboardService.prototype.multipleCellRange = function (clipboardGridData, currentRow, updatedRowNodes, columnsToPasteInto, cellsToFlash, updatedColumnIds, type) {\n        var _this = this;\n        clipboardGridData.forEach(function (clipboardRowData) {\n            // if we have come to end of rows in grid, then skip\n            if (!currentRow) {\n                return;\n            }\n            var rowNode = _this.getRowNode(currentRow);\n            updatedRowNodes.push(rowNode);\n            clipboardRowData.forEach(function (value, index) {\n                var column = columnsToPasteInto[index];\n                if (main_1.Utils.missing(column)) {\n                    return;\n                }\n                if (!column.isCellEditable(rowNode)) {\n                    return;\n                }\n                _this.updateCellValue(rowNode, column, value, currentRow, cellsToFlash, updatedColumnIds, type);\n            });\n            // move to next row down for next set of values\n            currentRow = _this.cellNavigationService.getRowBelow(currentRow);\n        });\n        return currentRow;\n    };\n    ClipboardService.prototype.singleCellRange = function (parsedData, updatedRowNodes, currentRow, cellsToFlash, updatedColumnIds) {\n        var _this = this;\n        var value = parsedData[0][0];\n        var rowCallback = function (gridRow, rowNode, columns) {\n            updatedRowNodes.push(rowNode);\n            columns.forEach(function (column) {\n                if (column.isCellEditable(rowNode)) {\n                    _this.updateCellValue(rowNode, column, value, currentRow, cellsToFlash, updatedColumnIds, main_1.Constants.EXPORT_TYPE_CLIPBOARD);\n                }\n            });\n        };\n        this.iterateActiveRanges(false, rowCallback);\n    };\n    ClipboardService.prototype.updateCellValue = function (rowNode, column, value, currentRow, cellsToFlash, updatedColumnIds, type) {\n        if (column.isSuppressPaste(rowNode)) {\n            return;\n        }\n        var processedValue = this.userProcessCell(rowNode, column, value, this.gridOptionsWrapper.getProcessCellFromClipboardFunc(), type);\n        this.valueService.setValue(rowNode, column, processedValue);\n        var gridCellDef = {\n            rowIndex: currentRow.rowIndex,\n            floating: currentRow.floating,\n            column: column\n        };\n        var cellId = new main_1.GridCell(gridCellDef).createId();\n        cellsToFlash[cellId] = true;\n        if (updatedColumnIds.indexOf(column.getId()) < 0) {\n            updatedColumnIds.push(column.getId());\n        }\n    };\n    ClipboardService.prototype.copyToClipboard = function (includeHeaders) {\n        if (includeHeaders === void 0) {\n            includeHeaders = false;\n        }\n        this.logger.log(\"copyToClipboard: includeHeaders = \" + includeHeaders);\n        var selectedRowsToCopy = !this.selectionController.isEmpty()\n            && !this.gridOptionsWrapper.isSuppressCopyRowsToClipboard();\n        // default is copy range if exists, otherwise rows\n        if (this.rangeController.isMoreThanOneCell()) {\n            this.copySelectedRangeToClipboard(includeHeaders);\n        }\n        else if (selectedRowsToCopy) {\n            // otherwise copy selected rows if they exist\n            this.copySelectedRowsToClipboard(includeHeaders);\n        }\n        else if (this.focusedCellController.isAnyCellFocused()) {\n            // if there is a focused cell, copy this\n            this.copyFocusedCellToClipboard(includeHeaders);\n        }\n        else {\n            // lastly if no focused cell, try range again. this can happen\n            // if use has cellSelection turned off (so no focused cell)\n            // but has a cell clicked, so there exists a cell range\n            // of exactly one cell (hence the first 'if' above didn't\n            // get executed).\n            this.copySelectedRangeToClipboard(includeHeaders);\n        }\n    };\n    ClipboardService.prototype.iterateActiveRanges = function (onlyFirst, rowCallback, columnCallback) {\n        var _this = this;\n        if (this.rangeController.isEmpty()) {\n            return;\n        }\n        var rangeSelections = this.rangeController.getCellRanges();\n        if (onlyFirst) {\n            var range = rangeSelections[0];\n            this.iterateActiveRange(range, rowCallback, columnCallback);\n        }\n        else {\n            rangeSelections.forEach(function (range) { return _this.iterateActiveRange(range, rowCallback, columnCallback); });\n        }\n    };\n    ClipboardService.prototype.iterateActiveRange = function (range, rowCallback, columnCallback) {\n        // get starting and ending row, remember rowEnd could be before rowStart\n        var startRow = range.start.getGridRow();\n        var endRow = range.end.getGridRow();\n        var startRowIsFirst = startRow.before(endRow);\n        var currentRow = startRowIsFirst ? startRow : endRow;\n        var lastRow = startRowIsFirst ? endRow : startRow;\n        if (main_1.Utils.exists(columnCallback)) {\n            columnCallback(range.columns);\n        }\n        var rangeIndex = 0;\n        while (true) {\n            var rowNode = this.getRowNode(currentRow);\n            rowCallback(currentRow, rowNode, range.columns, rangeIndex++);\n            if (currentRow.equals(lastRow)) {\n                break;\n            }\n            currentRow = this.cellNavigationService.getRowBelow(currentRow);\n            // this can happen if the user sets the active range manually, and sets a range\n            // that is outside of the grid, eg sets range rows 0 to 100, but grid has only 20 rows.\n            if (main_1._.missing(currentRow)) {\n                break;\n            }\n        }\n    };\n    ClipboardService.prototype.copySelectedRangeToClipboard = function (includeHeaders) {\n        var _this = this;\n        if (includeHeaders === void 0) {\n            includeHeaders = false;\n        }\n        if (this.rangeController.isEmpty()) {\n            return;\n        }\n        var deliminator = this.gridOptionsWrapper.getClipboardDeliminator();\n        var data = '';\n        var cellsToFlash = {};\n        // adds columns to the data\n        var columnCallback = function (columns) {\n            if (!includeHeaders) {\n                return;\n            }\n            columns.forEach(function (column, index) {\n                var value = _this.columnController.getDisplayNameForColumn(column, 'clipboard', true);\n                var processedValue = _this.userProcessHeader(column, value, _this.gridOptionsWrapper.getProcessHeaderForClipboardFunc());\n                if (index != 0) {\n                    data += deliminator;\n                }\n                if (main_1.Utils.exists(processedValue)) {\n                    data += processedValue;\n                }\n            });\n            data += '\\r\\n';\n        };\n        // adds cell values to the data\n        var rowCallback = function (currentRow, rowNode, columns) {\n            columns.forEach(function (column, index) {\n                var value = _this.valueService.getValue(column, rowNode);\n                var processedValue = _this.userProcessCell(rowNode, column, value, _this.gridOptionsWrapper.getProcessCellForClipboardFunc(), main_1.Constants.EXPORT_TYPE_CLIPBOARD);\n                if (index != 0) {\n                    data += deliminator;\n                }\n                if (main_1.Utils.exists(processedValue)) {\n                    data += processedValue;\n                }\n                var gridCellDef = { rowIndex: currentRow.rowIndex, floating: currentRow.floating, column: column };\n                var cellId = new main_1.GridCell(gridCellDef).createId();\n                cellsToFlash[cellId] = true;\n            });\n            data += '\\r\\n';\n        };\n        this.iterateActiveRanges(false, rowCallback, columnCallback);\n        this.copyDataToClipboard(data);\n        this.dispatchFlashCells(cellsToFlash);\n    };\n    ClipboardService.prototype.copyFocusedCellToClipboard = function (includeHeaders) {\n        if (includeHeaders === void 0) {\n            includeHeaders = false;\n        }\n        var focusedCell = this.focusedCellController.getFocusedCell();\n        if (main_1.Utils.missing(focusedCell)) {\n            return;\n        }\n        var currentRow = focusedCell.getGridRow();\n        var rowNode = this.getRowNode(currentRow);\n        var column = focusedCell.column;\n        var value = this.valueService.getValue(column, rowNode);\n        var processedValue = this.userProcessCell(rowNode, column, value, this.gridOptionsWrapper.getProcessCellForClipboardFunc(), main_1.Constants.EXPORT_TYPE_CLIPBOARD);\n        if (main_1._.missing(processedValue)) {\n            // copy the new line character to clipboard instead of an empty string, as the 'execCommand' will ignore it.\n            // this behaviour is consistent with how Excel works!\n            processedValue = '\\n';\n        }\n        var data = '';\n        if (includeHeaders) {\n            data = this.columnController.getDisplayNameForColumn(column, 'clipboard', true) + '\\r\\n';\n        }\n        data += processedValue.toString();\n        this.copyDataToClipboard(data);\n        var cellId = focusedCell.createId();\n        var cellsToFlash = {};\n        cellsToFlash[cellId] = true;\n        this.dispatchFlashCells(cellsToFlash);\n    };\n    ClipboardService.prototype.dispatchFlashCells = function (cellsToFlash) {\n        var _this = this;\n        setTimeout(function () {\n            var event = {\n                type: main_1.Events.EVENT_FLASH_CELLS,\n                cells: cellsToFlash,\n                api: _this.gridApi,\n                columnApi: _this.columnApi\n            };\n            _this.eventService.dispatchEvent(event);\n        }, 0);\n    };\n    ClipboardService.prototype.userProcessCell = function (rowNode, column, value, func, type) {\n        if (func) {\n            var params = {\n                column: column,\n                node: rowNode,\n                value: value,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext(),\n                type: type\n            };\n            return func(params);\n        }\n        else {\n            return value;\n        }\n    };\n    ClipboardService.prototype.userProcessHeader = function (column, value, func) {\n        if (func) {\n            var params = {\n                column: column,\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n            return func(params);\n        }\n        else {\n            return value;\n        }\n    };\n    ClipboardService.prototype.getRowNode = function (gridRow) {\n        switch (gridRow.floating) {\n            case main_1.Constants.PINNED_TOP:\n                return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n            case main_1.Constants.PINNED_BOTTOM:\n                return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n            default:\n                return this.rowModel.getRow(gridRow.rowIndex);\n        }\n    };\n    ClipboardService.prototype.copySelectedRowsToClipboard = function (includeHeaders, columnKeys) {\n        if (includeHeaders === void 0) {\n            includeHeaders = false;\n        }\n        var skipHeader = !includeHeaders;\n        var deliminator = this.gridOptionsWrapper.getClipboardDeliminator();\n        var params = {\n            columnKeys: columnKeys,\n            skipHeader: skipHeader,\n            skipFooters: true,\n            suppressQuotes: true,\n            columnSeparator: deliminator,\n            onlySelected: true,\n            processCellCallback: this.gridOptionsWrapper.getProcessCellForClipboardFunc()\n        };\n        var data = this.csvCreator.getDataAsCsv(params);\n        this.copyDataToClipboard(data);\n    };\n    ClipboardService.prototype.copyDataToClipboard = function (data) {\n        var userProvidedFunc = this.gridOptionsWrapper.getSendToClipboardFunc();\n        if (main_1.Utils.exists(userProvidedFunc)) {\n            var params = { data: data };\n            userProvidedFunc(params);\n        }\n        else {\n            this.executeOnTempElement(function (element) {\n                element.value = data;\n                element.select();\n                element.focus();\n                return document.execCommand('copy');\n            });\n        }\n    };\n    ClipboardService.prototype.executeOnTempElement = function (callbackNow, callbackAfter) {\n        var eTempInput = document.createElement('textarea');\n        eTempInput.style.width = '1px';\n        eTempInput.style.height = '1px';\n        eTempInput.style.top = '0px';\n        eTempInput.style.left = '0px';\n        eTempInput.style.position = 'absolute';\n        eTempInput.style.opacity = '0.0';\n        var guiRoot = this.gridCore.getRootGui();\n        guiRoot.appendChild(eTempInput);\n        try {\n            var result = callbackNow(eTempInput);\n            this.logger.log('Clipboard operation result: ' + result);\n        }\n        catch (err) {\n            this.logger.log('Browser doesn\\t support document.execComment(\\'copy\\') for clipboard operations');\n        }\n        //It needs 100 otherwise OS X seemed to not always be able to paste... Go figure...\n        if (callbackAfter) {\n            setTimeout(function () {\n                callbackAfter(eTempInput);\n                guiRoot.removeChild(eTempInput);\n            }, 100);\n        }\n        else {\n            guiRoot.removeChild(eTempInput);\n        }\n    };\n    // From http://stackoverflow.com/questions/1293147/javascript-code-to-parse-csv-data\n    // This will parse a delimited string into an array of arrays.\n    // Note: this code fixes an issue with the example posted on stack overflow where it doesn't correctly handle\n    // empty values in the first cell.\n    ClipboardService.prototype.dataToArray = function (strData) {\n        var delimiter = this.gridOptionsWrapper.getClipboardDeliminator();\n        // Create a regular expression to parse the CSV values.\n        var objPattern = new RegExp((\n        // Delimiters.\n        \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n            // Quoted fields.\n            \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n            // Standard fields.\n            \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\"), \"gi\");\n        // Create an array to hold our data. Give the array\n        // a default empty first row.\n        var arrData = [[]];\n        // Create an array to hold our individual pattern matching groups.\n        var arrMatches;\n        // Required for handling edge case on first row copy\n        var atFirstRow = true;\n        // Keep looping over the regular expression matches\n        // until we can no longer find a match.\n        while (arrMatches = objPattern.exec(strData)) {\n            // Get the delimiter that was found.\n            var strMatchedDelimiter = arrMatches[1];\n            // Handles case when first row is an empty cell, insert an empty string before delimiter\n            if (atFirstRow && strMatchedDelimiter) {\n                arrData[0].push(\"\");\n            }\n            // Check to see if the given delimiter has a length\n            // (is not the start of string) and if it matches\n            // field delimiter. If id does not, then we know\n            // that this delimiter is a row delimiter.\n            if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n                // Since we have reached a new row of data,\n                // add an empty row to our data array.\n                arrData.push([]);\n            }\n            var strMatchedValue = void 0;\n            // Now that we have our delimiter out of the way,\n            // let's check to see which kind of value we\n            // captured (quoted or unquoted).\n            if (arrMatches[2]) {\n                // We found a quoted value. When we capture\n                // this value, unescaped any double quotes.\n                strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n            }\n            else {\n                // We found a non-quoted value.\n                strMatchedValue = arrMatches[3];\n            }\n            // Now that we have our value string, let's add\n            // it to the data array.\n            arrData[arrData.length - 1].push(strMatchedValue);\n            atFirstRow = false;\n        }\n        // Return the parsed data.\n        return arrData;\n    };\n    ClipboardService.prototype.rangeSize = function () {\n        var ranges = this.rangeController.getCellRanges();\n        var _a = [ranges[0].start.rowIndex, ranges[0].end.rowIndex], startRange = _a[0], endRange = _a[1];\n        return (startRange > endRange ? startRange - endRange : endRange - startRange) + 1;\n    };\n    __decorate([\n        main_1.Autowired('csvCreator'),\n        __metadata(\"design:type\", main_1.CsvCreator)\n    ], ClipboardService.prototype, \"csvCreator\", void 0);\n    __decorate([\n        main_1.Autowired('loggerFactory'),\n        __metadata(\"design:type\", main_1.LoggerFactory)\n    ], ClipboardService.prototype, \"loggerFactory\", void 0);\n    __decorate([\n        main_1.Autowired('selectionController'),\n        __metadata(\"design:type\", main_1.SelectionController)\n    ], ClipboardService.prototype, \"selectionController\", void 0);\n    __decorate([\n        main_1.Autowired('rangeController'),\n        __metadata(\"design:type\", rangeController_1.RangeController)\n    ], ClipboardService.prototype, \"rangeController\", void 0);\n    __decorate([\n        main_1.Autowired('rowModel'),\n        __metadata(\"design:type\", Object)\n    ], ClipboardService.prototype, \"rowModel\", void 0);\n    __decorate([\n        main_1.Autowired('pinnedRowModel'),\n        __metadata(\"design:type\", main_1.PinnedRowModel)\n    ], ClipboardService.prototype, \"pinnedRowModel\", void 0);\n    __decorate([\n        main_1.Autowired('valueService'),\n        __metadata(\"design:type\", main_1.ValueService)\n    ], ClipboardService.prototype, \"valueService\", void 0);\n    __decorate([\n        main_1.Autowired('focusedCellController'),\n        __metadata(\"design:type\", main_1.FocusedCellController)\n    ], ClipboardService.prototype, \"focusedCellController\", void 0);\n    __decorate([\n        main_1.Autowired('rowRenderer'),\n        __metadata(\"design:type\", main_1.RowRenderer)\n    ], ClipboardService.prototype, \"rowRenderer\", void 0);\n    __decorate([\n        main_1.Autowired('columnController'),\n        __metadata(\"design:type\", main_1.ColumnController)\n    ], ClipboardService.prototype, \"columnController\", void 0);\n    __decorate([\n        main_1.Autowired('eventService'),\n        __metadata(\"design:type\", main_1.EventService)\n    ], ClipboardService.prototype, \"eventService\", void 0);\n    __decorate([\n        main_1.Autowired('cellNavigationService'),\n        __metadata(\"design:type\", main_1.CellNavigationService)\n    ], ClipboardService.prototype, \"cellNavigationService\", void 0);\n    __decorate([\n        main_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", main_1.GridOptionsWrapper)\n    ], ClipboardService.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        main_1.Autowired('gridCore'),\n        __metadata(\"design:type\", main_1.GridCore)\n    ], ClipboardService.prototype, \"gridCore\", void 0);\n    __decorate([\n        main_1.Autowired('columnApi'),\n        __metadata(\"design:type\", main_1.ColumnApi)\n    ], ClipboardService.prototype, \"columnApi\", void 0);\n    __decorate([\n        main_1.Autowired('gridApi'),\n        __metadata(\"design:type\", main_1.GridApi)\n    ], ClipboardService.prototype, \"gridApi\", void 0);\n    __decorate([\n        main_1.PostConstruct,\n        __metadata(\"design:type\", Function),\n        __metadata(\"design:paramtypes\", []),\n        __metadata(\"design:returntype\", void 0)\n    ], ClipboardService.prototype, \"init\", null);\n    ClipboardService = __decorate([\n        main_1.Bean('clipboardService')\n    ], ClipboardService);\n    return ClipboardService;\n}());\nexports.ClipboardService = ClipboardService;\n",null]}