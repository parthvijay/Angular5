{"remainingRequest":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowStages/aggregationStage.js","dependencies":[{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/rowStages/aggregationStage.js","mtime":1523957359000},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/cache-loader/dist/cjs.js","mtime":1525383502481},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// ag-grid-enterprise v17.1.1\n\"use strict\";\nvar __decorate = /*@__PURE__*/ require(\"tslib\").__decorate;\nvar __metadata = /*@__PURE__*/ require(\"tslib\").__metadata;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar main_1 = require(\"ag-grid/main\");\nvar pivotStage_1 = require(\"./pivotStage\");\nvar aggFuncService_1 = require(\"../aggregation/aggFuncService\");\nvar AggregationStage = /*@__PURE__*/ (function () {\n    function AggregationStage() {\n    }\n    // it's possible to recompute the aggregate without doing the other parts\n    // + gridApi.recomputeAggregates()\n    AggregationStage.prototype.execute = function (params) {\n        // we don't do aggregation if doing legacy tree good\n        var doingLegacyTreeData = main_1._.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n        if (doingLegacyTreeData) {\n            return null;\n        }\n        var aggDetails = this.createAggDetails(params);\n        this.recursivelyCreateAggData(params.rowNode, aggDetails);\n    };\n    AggregationStage.prototype.createAggDetails = function (params) {\n        var pivotActive = this.columnController.isPivotActive();\n        var measureColumns = this.columnController.getValueColumns();\n        var pivotColumns = pivotActive ? this.columnController.getPivotColumns() : [];\n        var aggDetails = {\n            changedPath: params.changedPath,\n            valueColumns: measureColumns,\n            pivotColumns: pivotColumns\n        };\n        return aggDetails;\n    };\n    AggregationStage.prototype.recursivelyCreateAggData = function (rowNode, aggDetails) {\n        var _this = this;\n        // aggregate all children first, as we use the result in this nodes calculations\n        rowNode.childrenAfterFilter.forEach(function (child) {\n            var nodeHasChildren = child.hasChildren();\n            if (nodeHasChildren) {\n                _this.recursivelyCreateAggData(child, aggDetails);\n            }\n            else {\n                if (child.aggData) {\n                    child.setAggData(null);\n                }\n            }\n        });\n        //Optionally prevent the aggregation at the root Node\n        //https://ag-grid.atlassian.net/browse/AG-388\n        var isRootNode = rowNode.level === -1;\n        if (isRootNode) {\n            var notPivoting = !this.columnController.isPivotMode();\n            var suppressAggAtRootLevel = this.gridOptionsWrapper.isSuppressAggAtRootLevel();\n            if (suppressAggAtRootLevel && notPivoting) {\n                return;\n            }\n        }\n        var skipBecauseNoChangedPath = aggDetails.changedPath.isActive()\n            && !aggDetails.changedPath.isInPath(rowNode);\n        if (skipBecauseNoChangedPath) {\n            return;\n        }\n        this.aggregateRowNode(rowNode, aggDetails);\n    };\n    AggregationStage.prototype.aggregateRowNode = function (rowNode, aggDetails) {\n        var measureColumnsMissing = aggDetails.valueColumns.length === 0;\n        var pivotColumnsMissing = aggDetails.pivotColumns.length === 0;\n        var userFunc = this.gridOptionsWrapper.getGroupRowAggNodesFunc();\n        var aggResult;\n        if (userFunc) {\n            aggResult = userFunc(rowNode.childrenAfterFilter);\n        }\n        else if (measureColumnsMissing) {\n            aggResult = null;\n        }\n        else if (pivotColumnsMissing) {\n            aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, aggDetails);\n        }\n        else {\n            aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);\n        }\n        rowNode.setAggData(aggResult);\n        // if we are grouping, then it's possible there is a sibling footer\n        // to the group, so update the data here also if there is one\n        if (rowNode.sibling) {\n            rowNode.sibling.setAggData(aggResult);\n        }\n    };\n    AggregationStage.prototype.aggregateRowNodeUsingValuesAndPivot = function (rowNode) {\n        var _this = this;\n        var result = {};\n        var pivotColumnDefs = this.pivotStage.getPivotColumnDefs();\n        // Step 1: process value columns\n        pivotColumnDefs\n            .filter(function (v) { return !main_1.Utils.exists(v.pivotTotalColumnIds); }) // only process pivot value columns\n            .forEach(function (valueColDef) {\n            var keys = valueColDef.pivotKeys;\n            var values;\n            var valueColumn = valueColDef.pivotValueColumn;\n            if (rowNode.leafGroup) {\n                // lowest level group, get the values from the mapped set\n                values = _this.getValuesFromMappedSet(rowNode.childrenMapped, keys, valueColumn);\n            }\n            else {\n                // value columns and pivot columns, non-leaf group\n                values = _this.getValuesPivotNonLeaf(rowNode, valueColDef.colId);\n            }\n            result[valueColDef.colId] = _this.aggregateValues(values, valueColumn.getAggFunc());\n        });\n        // Step 2: process total columns\n        pivotColumnDefs\n            .filter(function (v) { return main_1.Utils.exists(v.pivotTotalColumnIds); }) // only process pivot total columns\n            .forEach(function (totalColDef) {\n            var aggResults = [];\n            //retrieve results for colIds associated with this pivot total column\n            totalColDef.pivotTotalColumnIds.forEach(function (colId) {\n                aggResults.push(result[colId]);\n            });\n            result[totalColDef.colId] = _this.aggregateValues(aggResults, totalColDef.aggFunc);\n        });\n        return result;\n    };\n    AggregationStage.prototype.aggregateRowNodeUsingValuesOnly = function (rowNode, aggDetails) {\n        var _this = this;\n        var result = {};\n        var changedValueColumns = aggDetails.changedPath.isActive() ?\n            aggDetails.changedPath.getValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : aggDetails.valueColumns;\n        var notChangedValueColumns = aggDetails.changedPath.isActive() ?\n            aggDetails.changedPath.getNotValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : null;\n        var values2d = this.getValuesNormal(rowNode, changedValueColumns);\n        var oldValues = rowNode.aggData;\n        changedValueColumns.forEach(function (valueColumn, index) {\n            result[valueColumn.getId()] = _this.aggregateValues(values2d[index], valueColumn.getAggFunc());\n        });\n        if (notChangedValueColumns && oldValues) {\n            notChangedValueColumns.forEach(function (valueColumn) {\n                result[valueColumn.getId()] = oldValues[valueColumn.getId()];\n            });\n        }\n        return result;\n    };\n    AggregationStage.prototype.getValuesPivotNonLeaf = function (rowNode, colId) {\n        var values = [];\n        rowNode.childrenAfterFilter.forEach(function (rowNode) {\n            var value = rowNode.aggData[colId];\n            values.push(value);\n        });\n        return values;\n    };\n    AggregationStage.prototype.getValuesFromMappedSet = function (mappedSet, keys, valueColumn) {\n        var _this = this;\n        var mapPointer = mappedSet;\n        keys.forEach(function (key) { return mapPointer = mapPointer ? mapPointer[key] : null; });\n        if (!mapPointer) {\n            return [];\n        }\n        var values = [];\n        mapPointer.forEach(function (rowNode) {\n            var value = _this.valueService.getValue(valueColumn, rowNode);\n            values.push(value);\n        });\n        return values;\n    };\n    AggregationStage.prototype.getValuesNormal = function (rowNode, valueColumns) {\n        // create 2d array, of all values for all valueColumns\n        var values = [];\n        valueColumns.forEach(function () { return values.push([]); });\n        var valueColumnCount = valueColumns.length;\n        var rowCount = rowNode.childrenAfterFilter.length;\n        for (var i = 0; i < rowCount; i++) {\n            var childNode = rowNode.childrenAfterFilter[i];\n            for (var j = 0; j < valueColumnCount; j++) {\n                var valueColumn = valueColumns[j];\n                // if the row is a group, then it will only have an agg result value,\n                // which means valueGetter is never used.\n                var value = this.valueService.getValue(valueColumn, childNode);\n                values[j].push(value);\n            }\n        }\n        return values;\n    };\n    AggregationStage.prototype.aggregateValues = function (values, aggFuncOrString) {\n        var aggFunction;\n        if (typeof aggFuncOrString === 'string') {\n            aggFunction = this.aggFuncService.getAggFunc(aggFuncOrString);\n        }\n        else {\n            aggFunction = aggFuncOrString;\n        }\n        if (typeof aggFunction !== 'function') {\n            console.error(\"ag-Grid: unrecognised aggregation function \" + aggFuncOrString);\n            return null;\n        }\n        return aggFunction(values);\n    };\n    __decorate([\n        main_1.Autowired('gridOptionsWrapper'),\n        __metadata(\"design:type\", main_1.GridOptionsWrapper)\n    ], AggregationStage.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        main_1.Autowired('columnController'),\n        __metadata(\"design:type\", main_1.ColumnController)\n    ], AggregationStage.prototype, \"columnController\", void 0);\n    __decorate([\n        main_1.Autowired('valueService'),\n        __metadata(\"design:type\", main_1.ValueService)\n    ], AggregationStage.prototype, \"valueService\", void 0);\n    __decorate([\n        main_1.Autowired('pivotStage'),\n        __metadata(\"design:type\", pivotStage_1.PivotStage)\n    ], AggregationStage.prototype, \"pivotStage\", void 0);\n    __decorate([\n        main_1.Autowired('aggFuncService'),\n        __metadata(\"design:type\", aggFuncService_1.AggFuncService)\n    ], AggregationStage.prototype, \"aggFuncService\", void 0);\n    AggregationStage = __decorate([\n        main_1.Bean('aggregationStage')\n    ], AggregationStage);\n    return AggregationStage;\n}());\nexports.AggregationStage = AggregationStage;\n",null]}