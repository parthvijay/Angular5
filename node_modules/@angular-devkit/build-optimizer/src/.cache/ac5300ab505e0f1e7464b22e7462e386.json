{"remainingRequest":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/setFilter/setFilterModel.js","dependencies":[{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/ag-grid-enterprise/dist/lib/setFilter/setFilterModel.js","mtime":1523957359000},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/cache-loader/dist/cjs.js","mtime":1525383502481},{"path":"/Users/pavijayv/Documents/cisco-ready-qualification/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["// ag-grid-enterprise v17.1.1\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar main_1 = require(\"ag-grid/main\");\nvar ag_grid_1 = require(\"ag-grid\");\n// we cannot have 'null' as a key in a JavaScript map,\n// it needs to be a string. so we use this string for\n// storing null values.\nvar NULL_VALUE = '___NULL___';\nvar SetFilterModelValuesType;\n(function (SetFilterModelValuesType) {\n    SetFilterModelValuesType[SetFilterModelValuesType[\"PROVIDED_LIST\"] = 0] = \"PROVIDED_LIST\";\n    SetFilterModelValuesType[SetFilterModelValuesType[\"PROVIDED_CB\"] = 1] = \"PROVIDED_CB\";\n    SetFilterModelValuesType[SetFilterModelValuesType[\"NOT_PROVIDED\"] = 2] = \"NOT_PROVIDED\";\n})(SetFilterModelValuesType = exports.SetFilterModelValuesType || (exports.SetFilterModelValuesType = {}));\nvar SetFilterModel = /*@__PURE__*/ (function () {\n    function SetFilterModel(colDef, rowModel, valueGetter, doesRowPassOtherFilters, suppressSorting, modelUpdatedFunc, isLoadingFunc, valueFormatterService, column) {\n        this.suppressSorting = suppressSorting;\n        this.colDef = colDef;\n        this.valueGetter = valueGetter;\n        this.doesRowPassOtherFilters = doesRowPassOtherFilters;\n        this.modelUpdatedFunc = modelUpdatedFunc;\n        this.isLoadingFunc = isLoadingFunc;\n        this.valueFormatterService = valueFormatterService;\n        this.column = column;\n        if (rowModel.getType() === ag_grid_1.Constants.ROW_MODEL_TYPE_IN_MEMORY) {\n            this.inMemoryRowModel = rowModel;\n        }\n        this.filterParams = this.colDef.filterParams ? this.colDef.filterParams : {};\n        if (main_1.Utils.exists(this.filterParams) && main_1.Utils.exists(this.filterParams.values)) {\n            this.valuesType = Array.isArray(this.filterParams.values) ?\n                SetFilterModelValuesType.PROVIDED_LIST :\n                SetFilterModelValuesType.PROVIDED_CB;\n            this.showingAvailableOnly = this.filterParams.suppressRemoveEntries !== true;\n        }\n        else {\n            this.valuesType = SetFilterModelValuesType.NOT_PROVIDED;\n            this.showingAvailableOnly = true;\n        }\n        this.createAllUniqueValues();\n        this.createAvailableUniqueValues();\n        // by default, no filter, so we display everything\n        this.displayedValues = this.availableUniqueValues;\n        this.miniFilter = null;\n        // we use a map rather than an array for the selected values as the lookup\n        // for a map is much faster than the lookup for an array, especially when\n        // the length of the array is thousands of records long\n        this.selectedValuesMap = {};\n        this.selectEverything();\n        this.formatter = this.filterParams.textFormatter ? this.filterParams.textFormatter : main_1.TextFilter.DEFAULT_FORMATTER;\n    }\n    // if keepSelection not set will always select all filters\n    // if keepSelection set will keep current state of selected filters\n    //    unless selectAll chosen in which case will select all\n    SetFilterModel.prototype.refreshAfterNewRowsLoaded = function (keepSelection, isSelectAll) {\n        this.createAllUniqueValues();\n        this.refreshSelection(keepSelection, isSelectAll);\n    };\n    // if keepSelection not set will always select all filters\n    // if keepSelection set will keep current state of selected filters\n    //    unless selectAll chosen in which case will select all\n    SetFilterModel.prototype.refreshValues = function (valuesToUse, keepSelection, isSelectAll) {\n        this.setValues(valuesToUse);\n        this.refreshSelection(keepSelection, isSelectAll);\n    };\n    SetFilterModel.prototype.refreshSelection = function (keepSelection, isSelectAll) {\n        this.createAvailableUniqueValues();\n        var oldModel = Object.keys(this.selectedValuesMap);\n        this.selectedValuesMap = {};\n        this.processMiniFilter();\n        if (keepSelection) {\n            this.setModel(oldModel, isSelectAll);\n        }\n        else {\n            this.selectEverything();\n        }\n    };\n    SetFilterModel.prototype.refreshAfterAnyFilterChanged = function () {\n        if (this.showingAvailableOnly) {\n            this.createAvailableUniqueValues();\n            this.processMiniFilter();\n        }\n    };\n    SetFilterModel.prototype.createAllUniqueValues = function () {\n        if (this.areValuesSync()) {\n            var valuesToUse = this.extractSyncValuesToUse();\n            this.setValues(valuesToUse);\n            this.filterValuesPromise = ag_grid_1.Promise.resolve(null);\n        }\n        else {\n            this.filterValuesExternalPromise = ag_grid_1.Promise.external();\n            this.filterValuesPromise = this.filterValuesExternalPromise.promise;\n            this.isLoadingFunc(true);\n            this.setValues([]);\n            var callback = this.filterParams.values;\n            var params = {\n                success: this.onAsyncValuesLoaded.bind(this),\n                colDef: this.colDef\n            };\n            callback(params);\n        }\n    };\n    SetFilterModel.prototype.onAsyncValuesLoaded = function (values) {\n        this.modelUpdatedFunc(values);\n        this.isLoadingFunc(false);\n        this.filterValuesExternalPromise.resolve(values);\n    };\n    SetFilterModel.prototype.areValuesSync = function () {\n        return this.valuesType == SetFilterModelValuesType.PROVIDED_LIST || this.valuesType == SetFilterModelValuesType.NOT_PROVIDED;\n    };\n    SetFilterModel.prototype.setValuesType = function (value) {\n        this.valuesType = value;\n    };\n    SetFilterModel.prototype.setValues = function (valuesToUse) {\n        this.allUniqueValues = valuesToUse;\n        if (!this.suppressSorting) {\n            this.sortValues(this.allUniqueValues);\n        }\n    };\n    SetFilterModel.prototype.extractSyncValuesToUse = function () {\n        var valuesToUse;\n        if (this.valuesType == SetFilterModelValuesType.PROVIDED_LIST) {\n            if (Array.isArray(this.filterParams.values)) {\n                valuesToUse = main_1.Utils.toStrings(this.filterParams.values);\n            }\n            else {\n                // In this case the values are async but have already been resolved, so we can reuse them\n                valuesToUse = this.allUniqueValues;\n            }\n        }\n        else if (this.valuesType == SetFilterModelValuesType.PROVIDED_CB) {\n            throw Error(\"ag-grid: Error extracting values to use. We should not extract the values synchronously when using a callback for the filterParams.values\");\n        }\n        else {\n            var uniqueValuesAsAnyObjects = this.getUniqueValues(false);\n            valuesToUse = main_1.Utils.toStrings(uniqueValuesAsAnyObjects);\n        }\n        return valuesToUse;\n    };\n    SetFilterModel.prototype.createAvailableUniqueValues = function () {\n        var dontCheckAvailableValues = !this.showingAvailableOnly || this.valuesType == SetFilterModelValuesType.PROVIDED_LIST || this.valuesType == SetFilterModelValuesType.PROVIDED_CB;\n        if (dontCheckAvailableValues) {\n            this.availableUniqueValues = this.allUniqueValues;\n            return;\n        }\n        var uniqueValuesAsAnyObjects = this.getUniqueValues(true);\n        this.availableUniqueValues = main_1.Utils.toStrings(uniqueValuesAsAnyObjects);\n        this.sortValues(this.availableUniqueValues);\n    };\n    SetFilterModel.prototype.sortValues = function (values) {\n        if (this.filterParams && this.filterParams.comparator) {\n            values.sort(this.filterParams.comparator);\n        }\n        else if (this.colDef.comparator) {\n            values.sort(this.colDef.comparator);\n        }\n        else {\n            values.sort(main_1.Utils.defaultComparator);\n        }\n    };\n    SetFilterModel.prototype.getUniqueValues = function (filterOutNotAvailable) {\n        var _this = this;\n        var uniqueCheck = {};\n        var result = [];\n        if (!this.inMemoryRowModel) {\n            console.error('ag-Grid: Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values');\n            return [];\n        }\n        this.inMemoryRowModel.forEachLeafNode(function (node) {\n            // only pull values from rows that have data. this means we skip filler group nodes.\n            if (!node.data) {\n                return;\n            }\n            var value = _this.valueGetter(node);\n            if (_this.colDef.keyCreator) {\n                value = _this.colDef.keyCreator({ value: value });\n            }\n            if (_this.colDef.refData) {\n                value = _this.colDef.refData[value];\n            }\n            if (value === \"\" || value === undefined) {\n                value = null;\n            }\n            if (filterOutNotAvailable) {\n                if (!_this.doesRowPassOtherFilters(node)) {\n                    return;\n                }\n            }\n            if (value != null && Array.isArray(value)) {\n                for (var j = 0; j < value.length; j++) {\n                    addUniqueValueIfMissing(value[j]);\n                }\n            }\n            else {\n                addUniqueValueIfMissing(value);\n            }\n        });\n        function addUniqueValueIfMissing(value) {\n            if (!uniqueCheck.hasOwnProperty(value)) {\n                result.push(value);\n                uniqueCheck[value] = 1;\n            }\n        }\n        return result;\n    };\n    //sets mini filter. returns true if it changed from last value, otherwise false\n    SetFilterModel.prototype.setMiniFilter = function (newMiniFilter) {\n        newMiniFilter = main_1.Utils.makeNull(newMiniFilter);\n        if (this.miniFilter === newMiniFilter) {\n            //do nothing if filter has not changed\n            return false;\n        }\n        this.miniFilter = newMiniFilter;\n        this.processMiniFilter();\n        return true;\n    };\n    SetFilterModel.prototype.getMiniFilter = function () {\n        return this.miniFilter;\n    };\n    SetFilterModel.prototype.processMiniFilter = function () {\n        // if no filter, just use the unique values\n        if (this.miniFilter === null) {\n            this.displayedValues = this.availableUniqueValues;\n            return;\n        }\n        // if filter present, we filter down the list\n        this.displayedValues = [];\n        var miniFilter = this.formatter(this.miniFilter);\n        // make upper case to have search case insensitive\n        var miniFilterUpperCase = miniFilter.toUpperCase();\n        for (var i = 0, l = this.availableUniqueValues.length; i < l; i++) {\n            var value = this.availableUniqueValues[i];\n            if (value) {\n                var displayedValue = this.formatter(value.toString());\n                //This function encapsulates the logic to check if a string matches the mini filter\n                var matchesFn = function (valueToCheck) {\n                    if (valueToCheck === null) {\n                        return false;\n                    }\n                    // allow for case insensitive searches, make both filter and value uppercase\n                    var valueUpperCase = valueToCheck.toUpperCase();\n                    return valueUpperCase.indexOf(miniFilterUpperCase) >= 0;\n                };\n                var formattedValue = this.valueFormatterService.formatValue(this.column, null, null, displayedValue);\n                if (matchesFn(displayedValue) || matchesFn(formattedValue)) {\n                    this.displayedValues.push(displayedValue);\n                }\n            }\n        }\n    };\n    SetFilterModel.prototype.getDisplayedValueCount = function () {\n        return this.displayedValues.length;\n    };\n    SetFilterModel.prototype.getDisplayedValue = function (index) {\n        return this.displayedValues[index];\n    };\n    SetFilterModel.prototype.selectEverything = function () {\n        if (!this.filterParams.selectAllOnMiniFilter || !this.miniFilter) {\n            this.selectOn(this.allUniqueValues);\n        }\n        else {\n            this.selectOn(this.displayedValues);\n        }\n    };\n    SetFilterModel.prototype.selectOn = function (toSelectOn) {\n        var count = toSelectOn.length;\n        for (var i = 0; i < count; i++) {\n            var key = toSelectOn[i];\n            var safeKey = this.valueToKey(key);\n            this.selectedValuesMap[safeKey] = null;\n        }\n        this.selectedValuesCount = count;\n    };\n    SetFilterModel.prototype.valueToKey = function (key) {\n        if (key === null) {\n            return NULL_VALUE;\n        }\n        else {\n            return key;\n        }\n    };\n    SetFilterModel.prototype.keyToValue = function (value) {\n        if (value === NULL_VALUE) {\n            return null;\n        }\n        else {\n            return value;\n        }\n    };\n    SetFilterModel.prototype.isFilterActive = function () {\n        return this.allUniqueValues.length !== this.selectedValuesCount;\n    };\n    SetFilterModel.prototype.selectNothing = function () {\n        var _this = this;\n        if (!this.filterParams.selectAllOnMiniFilter || !this.miniFilter) {\n            this.selectedValuesMap = {};\n            this.selectedValuesCount = 0;\n        }\n        else {\n            this.displayedValues.forEach(function (it) { return _this.unselectValue(it); });\n        }\n    };\n    SetFilterModel.prototype.getUniqueValueCount = function () {\n        return this.allUniqueValues.length;\n    };\n    SetFilterModel.prototype.getUniqueValue = function (index) {\n        return this.allUniqueValues[index];\n    };\n    SetFilterModel.prototype.unselectValue = function (value) {\n        var safeKey = this.valueToKey(value);\n        if (this.selectedValuesMap[safeKey] !== undefined) {\n            delete this.selectedValuesMap[safeKey];\n            this.selectedValuesCount--;\n        }\n    };\n    SetFilterModel.prototype.selectValue = function (value) {\n        var safeKey = this.valueToKey(value);\n        if (this.selectedValuesMap[safeKey] === undefined) {\n            this.selectedValuesMap[safeKey] = null;\n            this.selectedValuesCount++;\n        }\n    };\n    SetFilterModel.prototype.isValueSelected = function (value) {\n        var safeKey = this.valueToKey(value);\n        return this.selectedValuesMap[safeKey] !== undefined;\n    };\n    SetFilterModel.prototype.isEverythingSelected = function () {\n        var _this = this;\n        if (!this.filterParams.selectAllOnMiniFilter || !this.miniFilter) {\n            return this.allUniqueValues.length === this.selectedValuesCount;\n        }\n        else {\n            return this.displayedValues.filter(function (it) { return _this.isValueSelected(it); }).length === this.displayedValues.length;\n        }\n    };\n    SetFilterModel.prototype.isNothingSelected = function () {\n        var _this = this;\n        if (!this.filterParams.selectAllOnMiniFilter || !this.miniFilter) {\n            return this.selectedValuesCount === 0;\n        }\n        else {\n            return this.displayedValues.filter(function (it) { return _this.isValueSelected(it); }).length === 0;\n        }\n    };\n    SetFilterModel.prototype.getModel = function () {\n        var _this = this;\n        if (!this.isFilterActive()) {\n            return null;\n        }\n        var selectedValues = [];\n        main_1.Utils.iterateObject(this.selectedValuesMap, function (key) {\n            var value = _this.keyToValue(key);\n            selectedValues.push(value);\n        });\n        return selectedValues;\n    };\n    SetFilterModel.prototype.setModel = function (model, isSelectAll) {\n        var _this = this;\n        if (isSelectAll === void 0) {\n            isSelectAll = false;\n        }\n        if (this.areValuesSync()) {\n            this.setSyncModel(model, isSelectAll);\n        }\n        else {\n            this.filterValuesExternalPromise.promise.then(function (values) {\n                _this.modelUpdatedFunc(values, model);\n            });\n        }\n    };\n    SetFilterModel.prototype.setSyncModel = function (model, isSelectAll) {\n        if (isSelectAll === void 0) {\n            isSelectAll = false;\n        }\n        if (model && !isSelectAll) {\n            this.selectNothing();\n            for (var i = 0; i < model.length; i++) {\n                var rawValue = model[i];\n                var value = this.keyToValue(rawValue);\n                if (this.allUniqueValues.indexOf(value) >= 0) {\n                    this.selectValue(value);\n                }\n            }\n        }\n        else {\n            this.selectEverything();\n        }\n    };\n    SetFilterModel.prototype.onFilterValuesReady = function (callback) {\n        //This guarantees that if the user is racing to set values async into the set filter, only the first instance\n        //will be used\n        // ie Values are async and the user manually wants to override them before the retrieval of values is triggered\n        // (set filter values in the following example)\n        // http://plnkr.co/edit/eFka7ynvPj68tL3VJFWf?p=preview\n        this.filterValuesPromise.firstOneOnly(callback);\n    };\n    return SetFilterModel;\n}());\nexports.SetFilterModel = SetFilterModel;\n",null]}